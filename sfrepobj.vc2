*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfrepobj.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfreportband AS sfreportrecord OF "sfrepobj.vcx" 		&& Report band class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*m: add		&& Adds a new report item to the band
		*m: getreportobjects		&& Returns an array of report objects in this band
		*m: item		&& Returns an object reference to the specified item
		*m: ncount_access
		*m: remove		&& Removes the specified object from the band
		*p: cbandtype		&& The band type
		*p: conentry		&& The "on entry" expression for the band
		*p: conexit		&& The "on exit" expression for the band
		*p: ctargetalias		&& The target alias for detail bands
		*p: ladjustbandheight		&& .T. if the height of the band should be adjusted to fit the objects in it
		*p: lconstantheight		&& .T. if the band should be a constant height
		*p: ldeleteobjectsoutsideband		&& .T. to delete objects outside the band height; this is only used if lAdjustBandHeight is .F.
		*p: lpagefooter		&& .T. if this is a summary band and a page footer should be printed
		*p: lpageheader		&& .T. if this is a summary band and a page header should be printed
		*p: lstartonnewpage		&& .T. if this band should start on a new page
		*p: ncount		&& The number of items in the band
		*p: nheight		&& The height of the band
		*p: nnewpagewhenlessthan		&& Starts a group on a new page when there is less than this much space left on the current page
		*p: oitems		&& A collection of report objects in the band
		*p: oreport		&& A reference to the SFReportFile object that instantiated us
	*</DefinedPropArrayMethod>

	PROTECTED oitems,oreport
	cbandtype = 		&& The band type
	conentry = 		&& The "on entry" expression for the band
	conexit = 		&& The "on exit" expression for the band
	ctargetalias = 		&& The target alias for detail bands
	ladjustbandheight = .T.		&& .T. if the height of the band should be adjusted to fit the objects in it
	lconstantheight = .F.		&& .T. if the band should be a constant height
	ldeleteobjectsoutsideband = .T.		&& .T. to delete objects outside the band height; this is only used if lAdjustBandHeight is .F.
	lpagefooter = .F.		&& .T. if this is a summary band and a page footer should be printed
	lpageheader = .F.		&& .T. if this is a summary band and a page header should be printed
	lstartonnewpage = .F.		&& .T. if this band should start on a new page
	Name = "sfreportband"
	ncount = 0		&& The number of items in the band
	nheight = 0		&& The height of the band
	nnewpagewhenlessthan = 0		&& Starts a group on a new page when there is less than this much space left on the current page
	nobjecttype = 9
	oitems = 		&& A collection of report objects in the band
	oreport = .NULL.		&& A reference to the SFReportFile object that instantiated us
	_memberdata = <VFPData>
		<memberdata name="conentry" type="property" display="cOnEntry"/>
		<memberdata name="conentry_assign" type="method" display="cOnEntry_Assign"/>
		<memberdata name="conexit" type="property" display="cOnExit"/>
		<memberdata name="conexit_assign" type="method" display="cOnExit_Assign"/>
		<memberdata name="getreportobjects" type="method" display="GetReportObjects"/>
		<memberdata name="lconstantheight" type="property" display="lConstantHeight"/>
		<memberdata name="lconstantheight_assign" type="method" display="lConstantHeight_Assign"/>
		<memberdata name="lpagefooter" type="property" display="lPageFooter"/>
		<memberdata name="lpagefooter_assign" type="method" display="lPageFooter_Assign"/>
		<memberdata name="lpageheader" type="property" display="lPageHeader"/>
		<memberdata name="lpageheader_assign" type="method" display="lPageHeader_Assign"/>
		<memberdata name="lstartonnewpage" type="property" display="lStartOnNewPage"/>
		<memberdata name="lstartonnewpage_assign" type="method" display="lStartOnNewPage_Assign"/>
		<memberdata name="nheight" type="property" display="nHeight"/>
		<memberdata name="nheight_assign" type="method" display="nHeight_Assign"/>
		<memberdata name="oreport" type="property" display="oReport"/>
		<memberdata name="add" type="method" display="Add"/>
		<memberdata name="item" type="method" display="Item"/>
		<memberdata name="nnewpagewhenlessthan" type="property" display="nNewPageWhenLessThan"/>
		<memberdata name="ctargetalias" type="property" display="cTargetAlias"/>
		<memberdata name="ladjustbandheight" type="property" display="lAdjustBandHeight"/>
		<memberdata name="ldeleteobjectsoutsideband" type="property" display="lDeleteObjectsOutsideBand"/>
		<memberdata name="remove" type="method" display="Remove"/>
		<memberdata name="ncount" display="nCount"/>
		<memberdata name="ncount_access" display="nCount_Access"/>
		<memberdata name="oitems" display="oItems"/>
		<memberdata name="cbandtype" display="cBandType"/>
		</VFPData>
	
	PROCEDURE add		&& Adds a new report item to the band
		* Add a new report item to the band.
		
		lparameters tuType
		local lcObjType, ;
			lcClass, ;
			loItem
		with This
			if vartype(tuType) = 'C'
				lcObjType = upper(tuType)
		
		* Figure out which class to instantiate based on the report object type.
		
				do case
					case lcObjType = ccOBJECT_FIELD
						lcClass = 'SFReportField'
					case lcObjType = ccOBJECT_TEXT
						lcClass = 'SFReportText'
					case lcObjType = ccOBJECT_LINE
						lcClass = 'SFReportLine'
					case lcObjType = ccOBJECT_IMAGE
						lcClass = 'SFReportImage'
					case lcObjType = ccOBJECT_BOX
						lcClass = 'SFReportBox'
				endcase
				if upper(.ClassLibrary) $ set('CLASSLIB')
					loItem = createobject(lcClass, .oReport)
				else
					loItem = newobject(lcClass, .ClassLibrary, '', .oReport)
				endif upper(.ClassLibrary) $ set('CLASSLIB')
			else
				loItem = tuType
			endif vartype(tuType) = 'C'
		
		* Add the object to the collection, then return an object reference to it.
		
			.oItems.Add(loItem)
		endwith
		return loItem
		
	ENDPROC

	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		local lcBandType, ;
			lnCode, ;
			laObjects[1], ;
			lnObjects, ;
			lnMaxHeight, ;
			loObject
		dodefault(toRecord, toReport)
		with This
		
		* Set ObjCode based on the type of band this is.
		
			lcBandType = upper(.cBandType)
			do case
				case lcBandType = ccBAND_TITLE
					lnCode = cnREPOBJ_CODE_TITLE
				case lcBandType = ccBAND_PAGE_HEADER
					lnCode = cnREPOBJ_CODE_PGHEADER
				case lcBandType = ccBAND_COLUMN_HEADER
					lnCode = cnREPOBJ_CODE_COLHEADER
				case lcBandType = ccBAND_DETAIL_HEADER
					lnCode = cnREPOBJ_CODE_DETHEADER
				case lcBandType = ccBAND_DETAIL_FOOTER
					lnCode = cnREPOBJ_CODE_DETFOOTER
				case lcBandType = ccBAND_DETAIL
					lnCode = cnREPOBJ_CODE_DETAIL
				case lcBandType = ccBAND_COLUMN_FOOTER
					lnCode = cnREPOBJ_CODE_COLFOOTER
				case lcBandType = ccBAND_PAGE_FOOTER
					lnCode = cnREPOBJ_CODE_PGFOOTER
				case lcBandType = ccBAND_SUMMARY
					lnCode = cnREPOBJ_CODE_SUMMARY
					toRecord.EjectBefor = .lPageHeader
					toRecord.EjectAfter = .lPageFooter
				otherwise
					lnCode = 0
			endcase
			toRecord.ObjCode = lnCode
		
		* Handle the other properties.
		
			toRecord.Tag       = .cOnEntry
			toRecord.Tag2      = .cOnExit
			toRecord.Height    = .nHeight
			toRecord.Plain     = .lConstantHeight
			toRecord.PageBreak = .lStartOnNewPage
			toRecord.Width     = .nNewPageWhenLessThan
			toRecord.Expr      = .cTargetAlias
		endwith
		return
		
	ENDPROC

	PROCEDURE getreportobjects		&& Returns an array of report objects in this band
		* Fill an array of report objects. First we fill a temporary array with the
		* nVPosition + nHPosition values of all objects then sort that array so the
		* objects are in upper-left to lower-right order, then create elements in the
		* return array. Note: we don't sort if tlNoSort is .T., which preserves Z-order
		* for the objects (the higher recno() is, the higher is Z-order an object is).
		
		lparameters taReturn, ;
			tcFilter, ;
			tlNoSort
		local lnObjects, ;
			lnAdded, ;
			lnI, ;
			loObject, ;
			laObjects[1]
		assert type('taReturn', 1) = 'A' ;
			message 'SFReportBand: invalid taReturn parameter'
		with This
			lnObjects = .oItems.Count
			lnAdded   = 0
			if lnObjects > 0
				for lnI = 1 to lnObjects
					loObject = .oItems.Item(lnI)
					if empty(tcFilter) or evaluate(tcFilter)
						lnAdded = lnAdded + 1
						dimension laObjects[lnAdded, 2]
						laObjects[lnAdded, 1] = loObject
						laObjects[lnAdded, 2] = str(loObject.nVPosition, 11, 3) + ;
							str(loObject.nHPosition, 11, 3)
					endif empty(tcFilter) ...
				next lnI
				if lnAdded > 0
					if not tlNoSort
						asort(laObjects, 2)
					endif not tlNoSort
					dimension taReturn[lnAdded]
					for lnI = 1 to lnAdded
						taReturn[lnI] = laObjects[lnI, 1]
					next lnI
				endif lnAdded > 0
			endif lnObjects > 0
		endwith
		return lnAdded
		
	ENDPROC

	PROCEDURE Init
		* Set the band type to the specified type and create a collection for objects
		* in the band.
		
		lparameters tcBandType, ;
			toReport
		with This
			.cBandType = iif(vartype(tcBandType) = 'C', tcBandType, '')
			.oReport   = toReport
			.oItems    = createobject('Collection')
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE item		&& Returns an object reference to the specified item
		lparameters tuIndex
		local lnCount, ;
			loItem, ;
			lcName, ;
			loCurrItem
		with This
			lnCount = .oItems.Count
			loItem  = .NULL.
			do case
		
		* If there are no items, return null.
		
				case lnCount = 0
		
		* If the parameter was a valid index number, return that item.
		
				case vartype(tuIndex) $ 'NFIBY' and between(tuIndex, 1, lnCount)
					loItem = .oItems.Item(tuIndex)
		
		* If the parameter was a string, try to find an item with that name or unique
		* ID in the collection.
		
				case vartype(tuIndex) = 'C'
					lcName = upper(alltrim(tuIndex))
					for each loCurrItem in This.oItems foxobject
						if upper(loCurrItem.cName) == lcName or ;
							loCurrItem.cUniqueID == lcName
							loItem = loCurrItem
							exit
						endif upper(loCurrItem.cName) == lcName ...
					next loCurrItem
			endcase
		endwith
		return loItem
		
	ENDPROC

	PROCEDURE ncount_access
		return This.oItems.Count
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		with This
			do case
				case OBJCODE = cnREPOBJ_CODE_TITLE
					.cBandType = ccBAND_TITLE
				case OBJCODE = cnREPOBJ_CODE_PGHEADER
					.cBandType = ccBAND_PAGE_HEADER
				case OBJCODE = cnREPOBJ_CODE_COLHEADER
					.cBandType = ccBAND_COLUMN_HEADER
				case OBJCODE = cnREPOBJ_CODE_DETAIL
					.cBandType = ccBAND_DETAIL
				case OBJCODE = cnREPOBJ_CODE_COLFOOTER
					.cBandType = ccBAND_COLUMN_FOOTER
				case OBJCODE = cnREPOBJ_CODE_PGFOOTER
					.cBandType = ccBAND_PAGE_FOOTER
				case OBJCODE = cnREPOBJ_CODE_SUMMARY
					.cBandType = ccBAND_SUMMARY
				case OBJCODE = cnREPOBJ_CODE_DETHEADER
					.cBandType = ccBAND_DETAIL_HEADER
				case OBJCODE = cnREPOBJ_CODE_DETFOOTER
					.cBandType = ccBAND_DETAIL_FOOTER
			endcase
			.cOnEntry             = TAG
			.cOnExit              = TAG2
			.cTargetAlias         = EXPR
			.lConstantHeight      = PLAIN
			.lPageFooter          = EJECTBEFOR
			.lPageHeader          = EJECTAFTER
			.lStartOnNewPage      = PAGEBREAK
			.nHeight              = -HEIGHT
			.nNewPageWhenLessThan = -WIDTH
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		* Nuke member objects.
		
		local lnI
		if vartype(This.oItems) = 'O'
			for lnI = This.oItems.Count to 1 step -1
				This.oItems.Item(lnI).Release()
			next lnI
		endif vartype(This.oItems) = 'O'
		This.oItems  = .NULL.
		This.oReport = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE remove		&& Removes the specified object from the band
		lparameters tuIndex
		local lnCount, ;
			lnIndex, ;
			lcName, ;
			lnI, ;
			llReturn
		with This
			lnCount = .oItems.Count
			lnIndex = 0
			do case
		
		* If there are no items, we have nothing to remove.
		
				case lnCount = 0
		
		* If the parameter was a valid index number, use that index.
		
				case vartype(tuIndex) $ 'NFIBY' and between(tuIndex, 1, lnCount)
					lnIndex = tuIndex
		
		* If the parameter was a string, try to find an item with that name or unique
		* ID in the collection.
		
				case vartype(tuIndex) = 'C'
					lcName = upper(alltrim(tuIndex))
					for lnI = 1 to lnCount
						loCurrItem = .oItems.Item(lnI)
						if upper(loCurrItem.cName) == lcName or ;
							loCurrItem.cUniqueID == lcName
							lnIndex = lnI
							exit
						endif upper(loCurrItem.cName) == lcName ...
					next lnI
			endcase
		
		* Remove the item we found.
		
			if lnIndex > 0
				.oItems.Remove(lnIndex)
				llReturn = .T.
			endif lnIndex > 0
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportbase AS custom 		&& Base class for Custom objects
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: calledfromthisclass		&& Returns .T. if a method was called from this class
		*m: cleanup		&& Cleans up member references when the object is released or destroyed
		*m: release		&& Releases the object
		*m: releasemembers		&& Abstract method to nuke member references
		*p: cerrormessage		&& The message of an error
		*p: lerroroccurred		&& .T. if an error occurred
		*p: lrelease		&& .T. as the object is being released
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED lrelease
	cerrormessage = 		&& The message of an error
	lerroroccurred = .F.		&& .T. if an error occurred
	lrelease = .F.		&& .T. as the object is being released
	Name = "sfreportbase"
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="cerrormessage" type="property" display="cErrorMessage"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers" favorites="True"/>
		<memberdata name="calledfromthisclass" display="CalledFromThisClass"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFReportBase
		* Based On:						Custom
		* Purpose:						Base class for all report objects
		* Author:						Doug Hennig
		* Last revision:				04/26/2006
		* Include file:					SFCTRLS.H
		*
		* Changes in "Based On" class properties:
		*	Width:						17 so the object is small when dropped on a
		*								form
		*
		* Changes in "Based On" class methods:
		*	Destroy:					cleanup as the object is destroyed
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*
		* Custom public properties added:
		*	cErrorMessage:				the message of an error
		*	lErrorOccurred:				.T. if an error occurred
		*
		* Custom protected properties added:
		*	lRelease:					.T. as the object is being released
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	Release:					releases the object
		*	ReleaseMembers:				abstract method to nuke member references
		*
		* Custom protected methods added:
		*	CalledFromThisClass:		returns .T. if a method was called from this
		*								class
		*	Cleanup:					cleans up member references when the object is
		*								released or destroyed
		*==============================================================================
		
	ENDPROC

	PROCEDURE calledfromthisclass		&& Returns .T. if a method was called from this class
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Author:			Doug Hennig
		* Last Revision:	09/27/2001
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE cleanup		&& Cleans up member references when the object is released or destroyed
		*==============================================================================
		* Method:			Cleanup
		* Status:			Protected
		* Purpose:			Nuke member objects
		* Author:			Doug Hennig
		* Last Revision:	03/24/99
		* Parameters:		none
		* Returns:			.T. if everything succeeded
		* Environment in:	This.lRelease is .T. if we're already in the process of
		*						releasing
		* Environment out:	This.lRelease is .T.
		*					This.ReleaseMembers() was called
		* Notes:			This methods avoids use of "with This" to prevent potential
		*						problems with dangling object references
		*==============================================================================
		
		if This.lRelease
			return .F.
		endif This.lRelease
		This.lRelease = .T.
		This.ReleaseMembers()
		
	ENDPROC

	PROCEDURE Destroy
		* Cleanup as the object is destroyed.
		
		This.Cleanup()
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Last revision:	04/26/2006
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			llCOMMode, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		llCOMMode = inlist(_VFP.StartMode, 2, 3, 5)
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* If we're not running in a COM server, display a generic dialog box with an
		* option to display the debugger (this should only occur in a test
		* environment).
		
			case not llCOMMode
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Use COMRETURNERROR() if we're running in a COM server.
		
			case llCOMMode
				comreturnerror('', 'Error ' + lnError + ' occurred in line ' + ;
					transform(lnLine) + ' of ' + lcMethod)
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object. Note the avoidance of "with This" in this code to prevent
		* potential problems with dangling object references.
		
		if This.lRelease
			nodefault
			return .F.
		endif This.lRelease
		This.Cleanup()
		release This
		
	ENDPROC

	PROCEDURE releasemembers		&& Abstract method to nuke member references
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportbox AS sfreportshape OF "sfrepobj.vcx" 		&& Report box class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*p: lstretchtotallest		&& .T. to stretch the object relative to the tallest object in the band
		*p: ncurvature		&& The curvature for the shape (0 = none)
		*p: nfillpattern		&& The fill pattern for the object: 0 = none, 1 = solid, 2 = horizontal lines, 3 = vertical lines, 4 = diagonal lines, leaning left, 5 = diagonal lines, leaning right, 6 = grid, 7 = hatch
	*</DefinedPropArrayMethod>

	lstretchtotallest = .F.		&& .T. to stretch the object relative to the tallest object in the band
	Name = "sfreportbox"
	ncurvature = 0		&& The curvature for the shape (0 = none)
	nfillpattern = 0		&& The fill pattern for the object: 0 = none, 1 = solid, 2 = horizontal lines, 3 = vertical lines, 4 = diagonal lines, leaning left, 5 = diagonal lines, leaning right, 6 = grid, 7 = hatch
	nobjecttype = 7
	_memberdata = <VFPData>
		<memberdata name="calignment" type="property" display="cAlignment"/>
		<memberdata name="calignment_assign" type="method" display="cAlignment_Assign"/>
		<memberdata name="cname" type="property" display="cName"/>
		<memberdata name="cprintwhen" type="property" display="cPrintWhen"/>
		<memberdata name="cprintwhen_assign" type="method" display="cPrintWhen_Assign"/>
		<memberdata name="ctooltip" type="property" display="cTooltip"/>
		<memberdata name="lautocenter" type="property" display="lAutoCenter"/>
		<memberdata name="lautocenter_assign" type="method" display="lAutoCenter_Assign"/>
		<memberdata name="lprintinfirstwholeband" type="property" display="lPrintInFirstWholeBand"/>
		<memberdata name="lprintinfirstwholeband_assign" type="method" display="lPrintInFirstWholeBand_Assign"/>
		<memberdata name="lprintonnewpage" type="property" display="lPrintOnNewPage"/>
		<memberdata name="lprintonnewpage_assign" type="method" display="lPrintOnNewPage_Assign"/>
		<memberdata name="lprintrepeats" type="property" display="lPrintRepeats"/>
		<memberdata name="lprintrepeats_assign" type="method" display="lPrintRepeats_Assign"/>
		<memberdata name="lremovelineifblank" type="property" display="lRemoveLineIfBlank"/>
		<memberdata name="lremovelineifblank_assign" type="method" display="lRemoveLineIfBlank_Assign"/>
		<memberdata name="lstretchtotallest" type="property" display="lStretchToTallest"/>
		<memberdata name="lstretchtotallest_assign" type="method" display="lStretchToTallest_Assign"/>
		<memberdata name="ncurvature" type="property" display="nCurvature"/>
		<memberdata name="ncurvature_assign" type="method" display="nCurvature_Assign"/>
		<memberdata name="nfillpattern" type="property" display="nFillPattern"/>
		<memberdata name="nfillpattern_assign" type="property" display="nFillPattern_Assign"/>
		</VFPData>
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		dodefault(toRecord, toReport)
		with This
			toRecord.ObjCode    = 4
			toRecord.Offset     = .nCurvature
			toRecord.StretchTop = .lStretchToTallest
			toRecord.Height     = .nHeight
			toRecord.Width      = .nWidth
			toRecord.FillPat    = .nFillPattern
		endwith
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		with This
			.lStretchToTallest = STRETCHTOP
			.nCurvature        = OFFSET
			.nFillPattern      = FILLPAT
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportde AS sfreportrecord OF "sfrepobj.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*p: cmethods		&& Method code for the DataEnvironment
		*p: lprivatedatasession		&& .T. for a private datasession
	*</DefinedPropArrayMethod>

	cmethods = 		&& Method code for the DataEnvironment
	lprivatedatasession = .F.		&& .T. for a private datasession
	Name = "sfreportde"
	nobjecttype = 25
	_memberdata = <VFPData>
		<memberdata name="cmethods" type="property" display="cMethods"/>
		<memberdata name="lprivatedatasession" type="property" display="lPrivateDatasession"/>
		</VFPData>
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		local lcFile1, ;
			lcFile2
		dodefault(toRecord, toReport)
		with toRecord
			.Name    = 'dataenvironment'
			.Expr    = 'Name = "Dataenvironment"' + iif(empty(This.cComment), '', ;
				ccCR + ccLF + 'Comment = "' + This.cComment + '"')
			.Environ = This.lPrivateDataSession
			.Tag     = This.cMethods
			if not empty(.Tag)
				lcFile1 = forceext(addbs(sys(2023)) + sys(2015), 'prg')
				lcFile2 = forceext(lcFile1, 'fxp')
				strtofile(.Tag, lcFile1)
				compile (lcFile1)
				.Tag2 = filetostr(lcFile2)
				erase (lcFile1)
				erase (lcFile2)
			endif not empty(.Tag)
		endwith
		return
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportfield AS sfreportobject OF "sfrepobj.vcx" 		&& Report field class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*m: cexpression_assign
		*m: cfontname_assign
		*m: getdefaultheight		&& Gets the default height for the object
		*m: lfontbold_assign
		*m: lfontitalic_assign
		*m: lfontunderline_assign
		*m: nfontsize_assign
		*p: ccaption		&& The design-time caption for the field
		*p: cdatatype		&& The data type of the expression: "N" for numeric, "D" for date, and "C" for everything else
		*p: cexpression		&& The expression to display
		*p: cfontname		&& The font to use
		*p: cfontstyle		&& The font style selected
		*p: cpicture		&& The picture for the field
		*p: ctotaltype		&& The total type: "N" for none, "C" for count, "S" for sum, "A" for average, "L" for lowest, "H" for highest, "D" for standard deviation, and "V" for variance
		*p: lexpressiontoolong		&& .T. if the expression is > 255 characters
		*p: lfontbold		&& .T. if the object should be bolded
		*p: lfontitalic		&& .T. if the object should be in italics
		*p: lfontunderline		&& .T. if the object should be underlined
		*p: lresetonpage		&& .T. to reset the variable at the end of each page; .F. to reset at the end of the report
		*p: ndatatrimming		&& Specifies how the Trim Mode for Character Expressions is set
		*p: nfontcharset		&& The font charset to use
		*p: nfontsize		&& The font size to use
		*p: nfontstyle		&& The font style value to use (written directly to the FRX)
		*p: nresetondetail		&& The detail band number to reset the value on
		*p: nresetongroup		&& The group number to reset the value on
		*p: oreport		&& A reference to the SFReportFile object this object is attached to
	*</DefinedPropArrayMethod>

	PROTECTED oreport
	ccaption = 		&& The design-time caption for the field
	cdatatype = C		&& The data type of the expression: "N" for numeric, "D" for date, and "C" for everything else
	cexpression = 		&& The expression to display
	cfontname = 		&& The font to use
	cfontstyle = 		&& The font style selected
	cpicture = 		&& The picture for the field
	ctotaltype = N		&& The total type: "N" for none, "C" for count, "S" for sum, "A" for average, "L" for lowest, "H" for highest, "D" for standard deviation, and "V" for variance
	lexpressiontoolong = .F.		&& .T. if the expression is > 255 characters
	lfontbold = .F.		&& .T. if the object should be bolded
	lfontitalic = .F.		&& .T. if the object should be in italics
	lfontunderline = .F.		&& .T. if the object should be underlined
	lresetonpage = .F.		&& .T. to reset the variable at the end of each page; .F. to reset at the end of the report
	Name = "sfreportfield"
	ndatatrimming = 0		&& Specifies how the Trim Mode for Character Expressions is set
	nfontcharset = 1		&& The font charset to use
	nfontsize = 0		&& The font size to use
	nfontstyle = -1		&& The font style value to use (written directly to the FRX)
	nheight = 1
	nobjecttype = 8
	nresetondetail = 0		&& The detail band number to reset the value on
	nresetongroup = 0		&& The group number to reset the value on
	oreport = .NULL.		&& A reference to the SFReportFile object this object is attached to
	_memberdata = <VFPData>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="ccaption_assign" type="method" display="cCaption_Assign"/>
		<memberdata name="cdatatype" type="property" display="cDataType"/>
		<memberdata name="cdatatype_assign" type="method" display="cDataType_Assign"/>
		<memberdata name="cexpression" type="property" display="cExpression"/>
		<memberdata name="cexpression_assign" type="method" display="cExpression_Assign"/>
		<memberdata name="cfontname" type="property" display="cFontName"/>
		<memberdata name="cfontname_assign" type="method" display="cFontName_Assign"/>
		<memberdata name="cfontstyle" type="property" display="cFontStyle"/>
		<memberdata name="cpicture" type="property" display="cPicture"/>
		<memberdata name="cpicture_assign" type="method" display="cPicture_Assign"/>
		<memberdata name="ctotaltype" type="property" display="cTotalType"/>
		<memberdata name="ctotaltype_assign" type="method" display="cTotalType_Assign"/>
		<memberdata name="lfontbold" type="property" display="lFontBold"/>
		<memberdata name="lfontbold_assign" type="method" display="lFontBold_Assign"/>
		<memberdata name="lfontitalic" type="property" display="lFontItalic"/>
		<memberdata name="lfontitalic_assign" type="method" display="lFontItalic_Assign"/>
		<memberdata name="lfontunderline" type="property" display="lFontUnderline"/>
		<memberdata name="lfontunderline_assign" type="method" display="lFontUnderline_Assign"/>
		<memberdata name="lresetonpage" type="property" display="lResetOnPage"/>
		<memberdata name="lresetonpage_assign" type="method" display="lResetOnPage_Assign"/>
		<memberdata name="ndatatrimming" type="property" display="nDataTrimming"/>
		<memberdata name="ndatatrimming_assign" type="method" display="nDataTrimming_Assign"/>
		<memberdata name="nfontsize" type="property" display="nFontSize"/>
		<memberdata name="nfontsize_assign" type="method" display="nFontSize_Assign"/>
		<memberdata name="nresetongroup" type="property" display="nResetOnGroup"/>
		<memberdata name="nresetongroup_assign" type="method" display="nResetOnGroup_Assign"/>
		<memberdata name="oreport" type="property" display="oReport"/>
		<memberdata name="nfontstyle" type="property" display="nFontStyle"/>
		<memberdata name="nfontcharset" display="nFontCharSet"/>
		<memberdata name="nresetondetail" display="nResetOnDetail"/>
		<memberdata name="lexpressiontoolong" display="lExpressionTooLong"/>
		<memberdata name="getdefaultheight" display="GetDefaultHeight"/>
		</VFPData>
	
	PROCEDURE cexpression_assign
		lparameter tcValue
		local lcValue
		with This
			lcValue = tcValue
			if len(tcValue) > 255
				lcValue = '"*** Invalid ***"'
				.lExpressionTooLong = .T.
			else
				.lExpressionTooLong = .F.
			endif len(tcValue) > 255
			store lcValue to .cExpression, .cName
		endwith
		
	ENDPROC

	PROCEDURE cfontname_assign
		lparameter tcValue
		local lnHeight
		with This
			.cFontName = tcValue
			if vartype(.oReport) = 'O'
				lnHeight = .GetDefaultHeight()
				if .nHeight <> lnHeight and not .CalledFromThisClass()
					.nHeight = lnHeight
				endif .nHeight <> lnHeight ...
			endif vartype(.oReport) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		local lcAlign, ;
			lcPicture, ;
			lcFormat, ;
			lcTotalType, ;
			lnFontStyle
		dodefault(toRecord, toReport)
		with This
		
		* Handle the object's alignment.
		
			lcAlign = upper(.cAlignment)
			do case
				case lcAlign = upper(ccALIGN_CENTER)
					toRecord.Offset = cnALIGN_CENTER
				case lcAlign = upper(ccALIGN_RIGHT)
					toRecord.Offset = cnALIGN_RIGHT
				otherwise
					toRecord.Offset = cnALIGN_LEFT
			endcase
		
		* For a left-aligned numeric field, add @B to the picture if necessary. Also,
		* add quotes around the picture if necessary.
		
			lcPicture = .cPicture
			lcFormat  = ''
			if left(lcPicture, 1) = '@'
				lcFormat = left(lcPicture, at(' ', lcPicture))
			endif left(lcPicture, 1) = '@'
			do case
				case .cDataType <> 'N' or lcAlign <> upper(ccALIGN_LEFT) or ;
					'B' $ lcFormat
				case not empty(lcFormat)
					lcPicture = stuff(lcPicture, 2, 0, 'B')
				otherwise
					lcPicture = '@B ' + lcPicture
			endcase
			if not empty(lcPicture) and not left(lcPicture, 1) $ ["']
				lcPicture = '"' + lcPicture + '"'
			endif not empty(lcPicture) ...
			toRecord.ObjCode   = 0
			toRecord.Expr      = .cExpression
			toRecord.Name      = .cCaption
			toRecord.Picture   = lcPicture
			toRecord.FillChar  = .cDataType
		
		* Handle the total type and when to reset the total.
		
			lcTotalType = upper(left(.cTotalType, 1))
			do case
				case lcTotalType = ccTOTAL_NONE
					toRecord.TotalType = cnTOTAL_NONE
				case lcTotalType = ccTOTAL_COUNT
					toRecord.TotalType = cnTOTAL_COUNT
				case lcTotalType = ccTOTAL_SUM
					toRecord.TotalType = cnTOTAL_SUM
				case lcTotalType = ccTOTAL_AVERAGE
					toRecord.TotalType = cnTOTAL_AVERAGE
				case lcTotalType = ccTOTAL_LOWEST
					toRecord.TotalType = cnTOTAL_LOWEST
				case lcTotalType = ccTOTAL_HIGHEST
					toRecord.TotalType = cnTOTAL_HIGHEST
				case lcTotalType = ccTOTAL_STDDEV
					toRecord.TotalType = cnTOTAL_STDDEV
				case lcTotalType = ccTOTAL_VARIANCE
					toRecord.TotalType = cnTOTAL_VARIANCE
			endcase
			do case
				case .nResetOnGroup = 0 and .nResetOnDetail = 0
					toRecord.ResetTotal = iif(.lResetOnPage, 2, 1)
				case .nResetOnGroup > 0
					toRecord.ResetTotal = .nResetOnGroup + cnGROUP_OFFSET
				otherwise
					toRecord.ResetTotal = .nResetOnDetail + cnDETAIL_OFFSET
			endcase
		
		* Handle the font settings. If nFontStyle is a non-negative value, use it.
		* Otherwise, use the individual lFont* properties.
		
			lnFontStyle = iif(.nFontStyle >= 0, .nFontStyle, ;
				iif(.lFontBold, cnSTYLE_BOLD, 0) + ;
				iif(.lFontItalic, cnSTYLE_ITALIC, 0) + ;
				iif(.lFontUnderline, cnSTYLE_UNDERLINE, 0))
			toRecord.FontStyle = lnFontStyle
			toRecord.FontFace  = .cFontName
			toRecord.FontSize  = .nFontSize
		
		* Handle other settings.
		
			toRecord.RulerLines = .nDataTrimming
			toRecord.ResoID     = .nFontCharSet
			toRecord.Double     = .T.
				&& .T. means use the font charset
		endwith
		return
		
	ENDPROC

	PROCEDURE getdefaultheight		&& Gets the default height for the object
		* Get the default height for this object as one "row" high based on the current
		* font and size.
		
		return This.oReport.GetVValue(1, This)
		
	ENDPROC

	PROCEDURE Init
		* Use the default font name and size of the report as the default for this
		* object and set the default height as one "row" high. 
		
		lparameters toReport
		if vartype(toReport) = 'O'
			with This
				.oReport   = toReport
				.cFontName = toReport.cFontName
				.nFontSize = toReport.nFontSize
				.nHeight   = .GetDefaultHeight()
			endwith
		endif vartype(toReport) = 'O'
		dodefault()
		
	ENDPROC

	PROCEDURE lfontbold_assign
		lparameter tlValue
		with This
			.lFontBold = tlValue
			do case
				case 'B' $ .cFontStyle and not tlValue
					.cFontStyle = strtran(.cFontStyle, 'B')
				case not 'B' $ .cFontStyle and tlValue
					.cFontStyle = 'B' + .cFontStyle
			endcase
		endwith
		
	ENDPROC

	PROCEDURE lfontitalic_assign
		lparameter tlValue
		with This
			.lFontItalic = tlValue
			do case
				case 'I' $ .cFontStyle and not tlValue
					.cFontStyle = strtran(.cFontStyle, 'I')
				case not 'I' $ .cFontStyle and tlValue
					.cFontStyle = .cFontStyle + 'I'
			endcase
		endwith
		
	ENDPROC

	PROCEDURE lfontunderline_assign
		lparameter tlValue
		with This
			.lFontUnderline = tlValue
			do case
				case 'U' $ .cFontStyle and not tlValue
					.cFontStyle = strtran(.cFontStyle, 'U')
				case not 'U' $ .cFontStyle and tlValue
					.cFontStyle = 'U' + .cFontStyle
			endcase
		endwith
		
	ENDPROC

	PROCEDURE nfontsize_assign
		lparameter tnValue
		local lnHeight
		with This
			.nFontSize = tnValue
			if vartype(.oReport) = 'O'
				lnHeight = .GetDefaultHeight()
				if .nHeight <> lnHeight and not .CalledFromThisClass()
					.nHeight = lnHeight
				endif .nHeight <> lnHeight ...
			endif vartype(.oReport) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE readfromfrx
		local lcPicture, ;
			llLeft
		dodefault()
		with This
			.cCaption       = NAME
			.cDataType      = FILLCHAR
			.cExpression    = EXPR
			.cFontName      = FONTFACE
			.lFontBold      = bittest(FONTSTYLE, cnSTYLE_BOLD_BIT)
			.lFontItalic    = bittest(FONTSTYLE, cnSTYLE_ITALIC_BIT)
			.lFontUnderline = bittest(FONTSTYLE, cnSTYLE_UNDERLINE_BIT)
			.lResetOnPage   = RESETTOTAL = 2
			.nDataTrimming  = RULERLINES
			.nFontSize      = FONTSIZE
		*** TODO: if reset on detail band, value is detail band # + 79 (eg. 80 for detail band 1)
			.nResetOnGroup  = max(RESETTOTAL - cnGROUP_OFFSET, 0)
			if left(PICTURE, 1) $ ['"]
				.cPicture = substr(PICTURE, 2, len(PICTURE) - 2)
			else
				.cPicture = PICTURE
			endif left(PICTURE, 1) $ ['"]
		
		* If the picture contains @B, use left alignment.
		
			if left(.cPicture, 1) = '@'
				lcPicture = left(.cPicture, at(' ', .cPicture))
				llLeft    = 'B' $ lcPicture
			endif left(.cPicture, 1) = '@'
			do case
				case llLeft
					.cAlignment = ccALIGN_LEFT
				case Offset = cnALIGN_RIGHT
					.cAlignment = ccALIGN_RIGHT
				case Offset = cnALIGN_CENTER
					.cAlignment = ccALIGN_CENTER
				otherwise
					.cAlignment = ccALIGN_LEFT
			endcase
			do case
				case TOTALTYPE = cnTOTAL_NONE
					.cTotalType = ccTOTAL_NONE
				case TOTALTYPE = cnTOTAL_COUNT
					.cTotalType = ccTOTAL_COUNT
				case TOTALTYPE = cnTOTAL_SUM
					.cTotalType = ccTOTAL_SUM
				case TOTALTYPE = cnTOTAL_AVERAGE
					.cTotalType = ccTOTAL_AVERAGE
				case TOTALTYPE = cnTOTAL_LOWEST
					.cTotalType = ccTOTAL_LOWEST
				case TOTALTYPE = cnTOTAL_HIGHEST
					.cTotalType = ccTOTAL_HIGHEST
				case TOTALTYPE = cnTOTAL_STDDEV
					.cTotalType = ccTOTAL_STDDEV
				case TOTALTYPE = cnTOTAL_VARIANCE
					.cTotalType = ccTOTAL_VARIANCE
			endcase
			if DOUBLE
				.nFontCharSet = RESOID
			endif DOUBLE
		endwith
		
	ENDPROC

	PROCEDURE releasemembers
		This.oReport = .NULL.
		dodefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportfile AS sfreportbase OF "sfrepobj.vcx" 		&& Main report object class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*m: cfontname_assign
		*m: createdetailband		&& Creates a detail band
		*m: creategroupband		&& Creates a new group band
		*m: createreportfile		&& Creates the report file
		*m: createreportrecord		&& Creates a report record object
		*m: createvariable		&& Creates a report variable
		*m: cunits_assign
		*m: gethfactor		&& Calculates the horizontal factor for the specified font
		*m: gethvalue		&& Calculates a horizontal value in the units used by the report
		*m: getpaperwidth		&& Gets the max. paper width.
		*m: getprinterinfo		&& Returns printer information
		*m: getrelativevposition		&& Get the vertical position of the specified object relative to the start of its band
		*m: getreportband		&& Returns an object reference to the specified band
		*m: getvariable		&& Returns a variable object
		*m: getvfactor		&& Calculates the vertical factor for the specified font
		*m: getvvalue		&& Calculates a vertical values in the units used by the report
		*m: insertband		&& Inserts the specified band record into the report
		*m: insertbandobjects		&& Inserts records for the objects in the specified band into the report
		*m: insertde		&& Inserts a DataEnvironment record into the report
		*m: insertheader		&& Inserts a header record into the report
		*m: insertobjectgroup		&& Inserts a record for an object group
		*m: insertrecord		&& Inserts the specified record to the report file
		*m: inserttrailer		&& Inserts a trailer record into the report
		*m: insertvariable		&& Inserts a report variable into the report
		*m: llandscape_assign
		*m: load		&& Loads the specified FRX into report objects
		*m: loadfromcursor		&& Loads the FRX in the current work area into report objects
		*m: lwholepage_assign
		*m: ncolumnspacing_assign
		*m: ncolumns_assign
		*m: ndetailbands_access
		*m: nfontsize_assign
		*m: nfontstyle_assign
		*m: ngroups_access
		*m: nleftmargin_assign
		*m: save		&& Creates the report file
		*m: setcolumnwidth		&& Sets the width of the report based on column width
		*m: setvhfactors		&& Sets the vertical and horizontal factors we'll work with
		*p: cdevice		&& The name of the printer to use
		*p: cfontname		&& The default font for the report
		*p: cmemberdata		&& The member data for the report header record
		*p: creportfile		&& The name of the report file to create
		*p: ctag		&& The contents of TAG
		*p: ctag2		&& The contents of TAG2
		*p: cunits		&& The unit of measurement: "C" (characters), "I" (inches), or "M" (centimeters)
		*p: ladjustobjectwidths		&& .T. to ensure no objects are wider than the paper width
		*p: llandscape		&& For backward compatibility only; use nOrientation instead
		*p: lnodataenvironment		&& .T. to prevent the DataEnvironment from being edited
		*p: lnopreview		&& .T. to prevent the report from being previewed or printed in the Report Designer
		*p: lnoquickreport		&& .T. to prevent access to the Quick Report function
		*p: lprintcolumns		&& .T. to print records in columns across the page, .F. to print top to bottom then in columns
		*p: lprivatedatasession		&& .T. to use a private datasession with this report
		*p: lsetheaderwidth		&& .T. to set the width of the header record
		*p: lsummaryband		&& .T. if the report has a summary band
		*p: ltitleband		&& .T. if the report has a title band
		*p: lusinglandscape		&& .T. if we're using landscape (even if nOrientation isn't 2)
		*p: lwholepage		&& .T. to use the whole page, .F. to use the printable page
		*p: nband		&& The current band number being processed
		*p: ncolumns		&& The number of columns in the report
		*p: ncolumnspacing		&& The spacing between columns
		*p: ncustomwidth		&& The custom paper width to use
		*p: ndefaultsource		&& The default paper source for the report
		*p: ndetailbands		&& The number of detail bands in the report
		*p: nfirstobject		&& The record number for the first non-band object in the report
		*p: nfontsize		&& The default font size for the report
		*p: nfontstyle		&& The default font style for the report
		*p: ngroups		&& The number of groups in the report
		*p: nheight		&& The current report height
		*p: nhfactor		&& The factor to convert a horizontal character unit to a report unit
		*p: nleftmargin		&& The left margin for the report
		*p: nminpaperwidth		&& The minimum paper width
		*p: norientation		&& The orientation for the report: 0 = auto-set to landscape if the report is too wide for portrait, 1 = use portrait, 2 = use landscape
		*p: npaperlength		&& The paper length
		*p: npapersize		&& The paper size (see help for PRTINFO(2) for a list of values)
		*p: npaperwidth		&& The paper width
		*p: nrepwidth		&& The calculated report width
		*p: nrulerscale		&& The scale used for the ruler: 1 = inches, 2 = metric, 3 = pixels
		*p: nvfactor		&& The factor to convert a vertical character unit to a report unit
		*p: nwidth		&& The width of a column; -1 if there's only 1 column
		*p: ocolumnfooterband		&& An object reference to the column footer band object
		*p: ocolumnheaderband		&& An object reference to the column header band object
		*p: ode		&& An object reference to the object for the DataEnvironment record
		*p: odetailband		&& An object reference to the detail band object
		*p: odetailfooterband		&& A reference to a detail footer band
		*p: odetailheaderband		&& A reference to a detail header band
		*p: opagefooterband		&& An object reference to the page footer band object
		*p: opageheaderband		&& An object reference to the page header band object
		*p: osummaryband		&& An object reference to the summary band object
		*p: otitleband		&& An object reference to the title band object
		*a: adetailbands[1,0]		&& An array of detail bands and optionally detail header and footer bands
		*a: agroupbands[1,0]		&& An array of group header and footer band objects
		*a: aobjectgroups[1,2]		&& An array of object groups
		*a: apaper[1,0]		&& An array of paper dimensions
		*a: avariables[1,0]		&& An array of report variables
	*</DefinedPropArrayMethod>

	PROTECTED adetailbands,agroupbands,aobjectgroups,apaper,avariables,ctag,ctag2,lsetheaderwidth,lusinglandscape,nband,nfirstobject,nheight,nhfactor,nvfactor,ocolumnfooterband,ocolumnheaderband,ode,odetailband,odetailfooterband,odetailheaderband,opagefooterband,opageheaderband,osummaryband,otitleband
	cdevice = 		&& The name of the printer to use
	cfontname = Courier New		&& The default font for the report
	cmemberdata = 		&& The member data for the report header record
	creportfile = 		&& The name of the report file to create
	ctag = 		&& The contents of TAG
	ctag2 = 		&& The contents of TAG2
	cunits = C		&& The unit of measurement: "C" (characters), "I" (inches), or "M" (centimeters)
	ladjustobjectwidths = .T.		&& .T. to ensure no objects are wider than the paper width
	llandscape = .F.		&& For backward compatibility only; use nOrientation instead
	lnodataenvironment = .T.		&& .T. to prevent the DataEnvironment from being edited
	lnopreview = .F.		&& .T. to prevent the report from being previewed or printed in the Report Designer
	lnoquickreport = .T.		&& .T. to prevent access to the Quick Report function
	lprintcolumns = .F.		&& .T. to print records in columns across the page, .F. to print top to bottom then in columns
	lprivatedatasession = .F.		&& .T. to use a private datasession with this report
	lsetheaderwidth = .F.		&& .T. to set the width of the header record
	lsummaryband = .F.		&& .T. if the report has a summary band
	ltitleband = .F.		&& .T. if the report has a title band
	lusinglandscape = .F.		&& .T. if we're using landscape (even if nOrientation isn't 2)
	lwholepage = .F.		&& .T. to use the whole page, .F. to use the printable page
	Name = "sfreportfile"
	nband = 0		&& The current band number being processed
	ncolumns = 1		&& The number of columns in the report
	ncolumnspacing = 0		&& The spacing between columns
	ncustomwidth = 0		&& The custom paper width to use
	ndefaultsource = -1		&& The default paper source for the report
	ndetailbands = 0		&& The number of detail bands in the report
	nfirstobject = 0		&& The record number for the first non-band object in the report
	nfontsize = 10		&& The default font size for the report
	nfontstyle = 0		&& The default font style for the report
	ngroups = 0		&& The number of groups in the report
	nheight = 0		&& The current report height
	nhfactor = 0		&& The factor to convert a horizontal character unit to a report unit
	nleftmargin = 0		&& The left margin for the report
	nminpaperwidth = 0		&& The minimum paper width
	norientation = 0		&& The orientation for the report: 0 = auto-set to landscape if the report is too wide for portrait, 1 = use portrait, 2 = use landscape
	npaperlength = 0		&& The paper length
	npapersize = 1		&& The paper size (see help for PRTINFO(2) for a list of values)
	npaperwidth = 0		&& The paper width
	nrepwidth = 0		&& The calculated report width
	nrulerscale = 1		&& The scale used for the ruler: 1 = inches, 2 = metric, 3 = pixels
	nvfactor = 0		&& The factor to convert a vertical character unit to a report unit
	nwidth = -1		&& The width of a column; -1 if there's only 1 column
	ocolumnfooterband = .NULL.		&& An object reference to the column footer band object
	ocolumnheaderband = .NULL.		&& An object reference to the column header band object
	ode = .NULL.		&& An object reference to the object for the DataEnvironment record
	odetailband = .NULL.		&& An object reference to the detail band object
	odetailfooterband = .NULL.		&& A reference to a detail footer band
	odetailheaderband = .NULL.		&& A reference to a detail header band
	opagefooterband = .NULL.		&& An object reference to the page footer band object
	opageheaderband = .NULL.		&& An object reference to the page header band object
	osummaryband = .NULL.		&& An object reference to the summary band object
	otitleband = .NULL.		&& An object reference to the title band object
	_memberdata = <VFPData>
		<memberdata name="agroupbands" type="property" display="aGroupBands"/>
		<memberdata name="apaper" type="property" display="aPaper"/>
		<memberdata name="avariables" type="property" display="aVariables"/>
		<memberdata name="cfontname" type="property" display="cFontName"/>
		<memberdata name="cfontname_assign" type="method" display="cFontName_Assign"/>
		<memberdata name="creategroupband" type="method" display="CreateGroupBand"/>
		<memberdata name="createreportfile" type="method" display="CreateReportFile"/>
		<memberdata name="createreportrecord" type="method" display="CreateReportRecord"/>
		<memberdata name="createvariable" type="method" display="CreateVariable"/>
		<memberdata name="creportfile" type="property" display="cReportFile"/>
		<memberdata name="creportfile_assign" type="method" display="cReportFile_Assign"/>
		<memberdata name="cunits" type="property" display="cUnits"/>
		<memberdata name="cunits_assign" type="method" display="cUnits_Assign"/>
		<memberdata name="gethfactor" type="method" display="GetHFactor"/>
		<memberdata name="gethvalue" type="method" display="GetHValue"/>
		<memberdata name="getpaperwidth" type="method" display="GetPaperWidth"/>
		<memberdata name="getreportband" type="method" display="GetReportBand"/>
		<memberdata name="getvfactor" type="method" display="GetVFactor"/>
		<memberdata name="getvvalue" type="method" display="GetVValue"/>
		<memberdata name="insertband" type="method" display="InsertBand"/>
		<memberdata name="insertde" type="method" display="InsertDE"/>
		<memberdata name="insertheader" type="method" display="InsertHeader"/>
		<memberdata name="insertrecord" type="method" display="InsertRecord"/>
		<memberdata name="inserttrailer" type="method" display="InsertTrailer"/>
		<memberdata name="insertvariable" type="method" display="InsertVariable"/>
		<memberdata name="ladjustbandheight_assign" type="method" display="lAdjustBandHeight_Assign"/>
		<memberdata name="llandscape" type="property" display="lLandscape"/>
		<memberdata name="llandscape_assign" type="method" display="lLandscape_Assign"/>
		<memberdata name="lnodataenvironment" type="property" display="lNoDataEnvironment"/>
		<memberdata name="lnodataenvironment_assign" type="method" display="lNoDataEnvironment_Assign"/>
		<memberdata name="lnoquickreport" type="property" display="lNoQuickReport"/>
		<memberdata name="lnoquickreport_assign" type="method" display="lNoQuickReport_Assign"/>
		<memberdata name="load" type="method" display="Load"/>
		<memberdata name="lprintcolumns" type="property" display="lPrintColumns"/>
		<memberdata name="lprintcolumns_assign" type="method" display="lPrintColumns_Assign"/>
		<memberdata name="lprivatedatasession" type="property" display="lPrivateDatasession"/>
		<memberdata name="lprivatedatasession_assign" type="method" display="lPrivateDatasession_Assign"/>
		<memberdata name="lsetheaderwidth" type="property" display="lSetHeaderWidth"/>
		<memberdata name="lsummaryband" type="property" display="lSummaryBand"/>
		<memberdata name="lsummaryband_assign" type="method" display="lSummaryBand_Assign"/>
		<memberdata name="ltitleband" type="property" display="lTitleBand"/>
		<memberdata name="ltitleband_assign" type="method" display="lTitleBand_Assign"/>
		<memberdata name="lwholepage" type="property" display="lWholePage"/>
		<memberdata name="lwholepage_assign" type="method" display="lWholePage_Assign"/>
		<memberdata name="nband" type="property" display="nBand"/>
		<memberdata name="ncolumns" type="property" display="nColumns"/>
		<memberdata name="ncolumnspacing" type="property" display="nColumnSpacing"/>
		<memberdata name="ncolumnspacing_assign" type="method" display="nColumnSpacing_Assign"/>
		<memberdata name="ncolumns_assign" type="method" display="nColumns_Assign"/>
		<memberdata name="nfontsize" type="property" display="nFontSize"/>
		<memberdata name="nfontsize_assign" type="method" display="nFontSize_Assign"/>
		<memberdata name="nheight" type="property" display="nHeight"/>
		<memberdata name="nhfactor" type="property" display="nHFactor"/>
		<memberdata name="nleftmargin" type="property" display="nLeftMargin"/>
		<memberdata name="nleftmargin_assign" type="method" display="nLeftMargin_Assign"/>
		<memberdata name="norientation" type="property" display="nOrientation"/>
		<memberdata name="norientation_assign" type="method" display="nOrientation_Assign"/>
		<memberdata name="npapersize" type="property" display="nPaperSize"/>
		<memberdata name="nrepwidth" type="property" display="nRepWidth"/>
		<memberdata name="nrulerscale" type="property" display="nRulerScale"/>
		<memberdata name="nvfactor" type="property" display="nVFactor"/>
		<memberdata name="nwidth" type="property" display="nWidth"/>
		<memberdata name="ocolumnfooterband" type="property" display="oColumnFooterBand"/>
		<memberdata name="ocolumnheaderband" type="property" display="oColumnHeaderBand"/>
		<memberdata name="ode" type="property" display="oDE"/>
		<memberdata name="odetailband" type="property" display="oDetailBand"/>
		<memberdata name="opagefooterband" type="property" display="oPageFooterBand"/>
		<memberdata name="opageheaderband" type="property" display="oPageHeaderBand"/>
		<memberdata name="osummaryband" type="property" display="oSummaryBand"/>
		<memberdata name="otitleband" type="property" display="oTitleBand"/>
		<memberdata name="save" type="method" display="Save"/>
		<memberdata name="setcolumnwidth" type="method" display="SetColumnWidth"/>
		<memberdata name="setvhfactors" type="method" display="SetVHFactors"/>
		<memberdata name="loadfromcursor" type="method" display="LoadFromCursor"/>
		<memberdata name="lnopreview" type="property" display="lNoPreview"/>
		<memberdata name="lnopreview_assign" type="property" display="lNoPreview_Assign"/>
		<memberdata name="insertbandobjects" type="method" display="InsertBandObjects"/>
		<memberdata name="insertobjectgroup" type="method" display="InsertObjectGroup"/>
		<memberdata name="nfirstobject" type="property" display="nFirstObject"/>
		<memberdata name="cmemberdata" type="property" display="cMemberData"/>
		<memberdata name="nfontstyle" type="property" display="nFontStyle"/>
		<memberdata name="nfontstyle_assign" type="method" display="nFontStyle_Assign"/>
		<memberdata name="ngroups" type="property" display="nGroups"/>
		<memberdata name="ngroups_access" type="method" display="nGroups_Access"/>
		<memberdata name="getvariable" type="method" display="GetVariable"/>
		<memberdata name="getrelativevposition" type="method" display="GetRelativeVPosition"/>
		<memberdata name="ndefaultsource" type="property" display="nDefaultSource"/>
		<memberdata name="ladjustobjectwidths" type="property" display="lAdjustObjectWidths"/>
		<memberdata name="cdevice" display="cDevice"/>
		<memberdata name="ctag" display="cTag"/>
		<memberdata name="ctag2" display="cTag2"/>
		<memberdata name="npaperwidth" display="nPaperWidth"/>
		<memberdata name="npaperlength" display="nPaperLength"/>
		<memberdata name="nminpaperwidth" display="nMinPaperWidth"/>
		<memberdata name="lusinglandscape" display="lUsingLandscape"/>
		<memberdata name="odetailfooterband" display="oDetailFooterBand"/>
		<memberdata name="odetailheaderband" display="oDetailHeaderBand"/>
		<memberdata name="createdetailband" display="CreateDetailBand"/>
		<memberdata name="ndetailbands" display="nDetailBands"/>
		<memberdata name="ndetailbands_access" display="nDetailBands_Access"/>
		<memberdata name="adetailbands" display="aDetailBands"/>
		<memberdata name="aobjectgroups" display="aObjectGroups"/>
		<memberdata name="getprinterinfo" display="GetPrinterInfo"/>
		<memberdata name="ncustomwidth" display="nCustomWidth"/>
		</VFPData>
	
	PROCEDURE cfontname_assign
		lparameter tcValue
		This.cFontName = tcValue
		This.SetVHFactors()
		
	ENDPROC

	PROCEDURE createdetailband		&& Creates a detail band
		lparameters tlHeaderFooter
		local lnDetail, ;
			llOpen
		with This
			lnDetail = iif(isnull(.aDetailBands[1, 1]), 1, alen(.aDetailBands, 1) + 1)
			llOpen   = upper(.ClassLibrary) $ set('CLASSLIB')
			dimension .aDetailBands[lnDetail, 3]
			if llOpen
				.aDetailBands[lnDetail, 1] = createobject('SFReportBand', ;
					ccBAND_DETAIL, This)
			else
				.aDetailBands[lnDetail, 1] = newobject('SFReportBand', ;
					.ClassLibrary, '', ccBAND_DETAIL, This)
			endif llOpen
			do case
				case not tlHeaderFooter
					.aDetailBands[lnDetail, 2] = .NULL.
					.aDetailBands[lnDetail, 3] = .NULL.
				case llOpen
					.aDetailBands[lnDetail, 2] = createobject('SFReportBand', ;
						ccBAND_DETAIL_HEADER, This)
					.aDetailBands[lnDetail, 3] = createobject('SFReportBand', ;
						ccBAND_DETAIL_FOOTER, This)
				otherwise
					.aDetailBands[lnDetail, 2] = newobject('SFReportBand', ;
						.ClassLibrary, '', ccBAND_DETAIL_HEADER, This)
					.aDetailBands[lnDetail, 3] = newobject('SFReportBand', ;
						.ClassLibrary, '', ccBAND_DETAIL_FOOTER, This)
			endcase
		endwith
		
	ENDPROC

	PROCEDURE creategroupband		&& Creates a new group band
		local lnGroup, ;
			llOpen
		with This
			lnGroup = iif(isnull(.aGroupBands[1, 1]), 1, alen(.aGroupBands, 1) + 1)
			llOpen  = upper(.ClassLibrary) $ set('CLASSLIB')
			dimension .aGroupBands[lnGroup, 2]
			if llOpen
				.aGroupBands[lnGroup, 1] = createobject('SFReportGroup', ;
					ccBAND_GROUP_HEADER, This)
				.aGroupBands[lnGroup, 2] = createobject('SFReportGroup', ;
					ccBAND_GROUP_FOOTER, This)
			else
				.aGroupBands[lnGroup, 1] = newobject('SFReportGroup', .ClassLibrary, ;
					'', ccBAND_GROUP_HEADER, This)
				.aGroupBands[lnGroup, 2] = newobject('SFReportGroup', .ClassLibrary, ;
					'', ccBAND_GROUP_FOOTER, This)
			endif llOpen
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE createreportfile		&& Creates the report file
		local lcSafety, ;
			lcCursor, ;
			lnCounter
		with This
			lcSafety = set('SAFETY')
			set safety off
		
		* If we have a report template we can use, do so.
		
			if file('ReportStru.FRX')
				select 0
				use ReportStru.FRX
				copy to (.cReportFile)
		
		* Create a cursor, then create a report file from it.
		
			else
				lcCursor = sys(2015)
				create cursor (lcCursor) (FIELD1 C(1))
				create report (.cReportFile) from (lcCursor)
			endif file('ReportStru.FRX')
		
		* Check to see if the report file exists, in case there's a write caching
		* issue.
		
			lnCounter = 1
			declare Sleep in Win32API integer nMilliseconds
			do while not file(.cReportFile) and lnCounter < 10
				Sleep(1000)
				lnCounter = lnCounter + 1
			enddo while not file(.cReportFile) ...
		
		* Nuke the records in the report file.
		
			use (.cReportFile) exclusive
			cursorsetprop('Buffering', 1)
			zap
			if lcSafety = 'ON'
				set safety on
			endif lcSafety = 'ON'
		endwith
		return
		
	ENDPROC

	PROTECTED PROCEDURE createreportrecord		&& Creates a report record object
		local loRecord
		scatter name loRecord blank memo
		loRecord.Platform = 'WINDOWS'
		loRecord.UniqueID = sys(2015)
		return loRecord
		
	ENDPROC

	PROCEDURE createvariable		&& Creates a report variable
		local lnVariable, ;
			loVariable
		with This
			lnVariable = iif(isnull(.aVariables[1]), 1, alen(.aVariables) + 1)
			if upper(.ClassLibrary) $ set('CLASSLIB')
				loVariable = createobject('SFReportVariable')
			else
				loVariable = newobject('SFReportVariable', .ClassLibrary)
			endif upper(.ClassLibrary) $ set('CLASSLIB')
			dimension .aVariables[lnVariable]
			.aVariables[lnVariable] = loVariable
		endwith
		return loVariable
		
	ENDPROC

	PROCEDURE cunits_assign
		lparameter tcValue
		local lcValue
		lcValue = upper(left(tcValue, 1))
		if inlist(lcValue, ccUNITS_CHARACTERS, ccUNITS_INCHES, ccUNITS_CENTIMETERS)
			This.cUnits = lcValue
			This.SetVHFactors()
		endif inlist(lcValue, ...
		
	ENDPROC

	PROCEDURE gethfactor		&& Calculates the horizontal factor for the specified font
		lparameters toObject
		local loObject, ;
			lnMax, ;
			lnAvg, ;
			lnFactor
		loObject = iif(type('toObject.cFontName') = 'C' and ;
			not empty(toObject.cFontName) and toObject.nFontSize > 0, toObject, This)
		lnMax    = fontmetric(7, loObject.cFontName, loObject.nFontSize)
		lnAvg    = fontmetric(6, loObject.cFontName, loObject.nFontSize)
		if lnMax - lnAvg > 1
			lnFactor = txtwidth(ccAVG_CHAR, loObject.cFontName, loObject.nFontSize) * ;
				lnAvg * cnFACTOR
		else
			lnFactor = lnMax * cnFACTOR
		endif lnMax - lnAvg > 1
		return lnFactor
		
	ENDPROC

	PROCEDURE gethvalue		&& Calculates a horizontal value in the units used by the report
		lparameters tnValue, ;
			toObject
		local lnValue
		with This
			if .cUnits = ccUNITS_CHARACTERS
				lnValue = tnValue
			else
				lnValue = tnValue * .GetHFactor(toObject)/cnREPORT_UNITS
			endif .cUnits = ccUNITS_CHARACTERS
		endwith
		return lnValue
		
	ENDPROC

	PROCEDURE getpaperwidth		&& Gets the max. paper width.
		* Returns the width of the paper in report units based on the setting of
		* nPaperSize.
		
		lparameters tlLandscape
		local lnWidth, ;
			lnLength, ;
			lnHMargin, ;
			lnVMargin, ;
			loPrinter, ;
			lnDefWidth, ;
			lnDefLength, ;
			lcLibrary, ;
			loForms, ;
			lnDecimals, ;
			lnPageWidth, ;
			lnTemp
		 
		* Don't call this method if it was called before.
		
		if This.nPaperWidth > 0
			return This.nPaperWidth
		endif This.nPaperWidth > 0
		with This
		
		* Try to use GetPrinterInfo to get the default page dimensions.
		
			store 0 to lnWidth, lnLength
			store cnPRINTER_MARGIN to lnHMargin, lnVMargin
			loPrinter = .GetPrinterInfo()
			if vartype(loPrinter) = 'O' and vartype(.nPaperSize) = 'N'
				if .lWholePage
					lnDefWidth  = loPrinter.nPhysicalWidthInch
					lnDefLength = loPrinter.nPhysicalHeightInch
				else
					lnDefWidth  = loPrinter.nPrintableAreaWidthInch
					lnDefLength = loPrinter.nPrintableAreaHeightInch
				endif .lWholePage
				if type('oLogger') = 'O'
					oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: defwidth=' + ;
						transform(lnDefWidth) + ', deflength=' + transform(lnDefLength) + ;
						', nPaperSize=' + transform(.nPaperSize))
				endif type('oLogger') = 'O'
				lnHMargin = loPrinter.nPrinterMarginLeftInch + ;
					loPrinter.nPrinterMarginRightInch
				lnVMargin = loPrinter.nPrinterMarginTopInch + ;
					loPrinter.nPrinterMarginBottomInch
				if left(transform(lnHMargin), 1) = '*'
					store cnPRINTER_MARGIN to lnHMargin, lnVMargin
				endif left(transform(lnHMargin), 1) = '*'
				if type('oLogger') = 'O'
					oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: H margin=' + ;
						transform(lnHMargin) + ', V margin=' + transform(lnVMargin))
				endif type('oLogger') = 'O'
				lcLibrary = 'PrinterForms.prg'
		
		* Get the paper size.
		
				do case
		
		* If we have a valid paper size, get the dimensions.
		
					case between(.nPaperSize, 1, alen(.aPaper, 1))
						lnWidth  = .aPaper[.nPaperSize, 1]
						lnLength = .aPaper[.nPaperSize, 2]
						if type('oLogger') = 'O'
							oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
								'using standard paper size ' + transform(.nPaperSize))
						endif type('oLogger') = 'O'
		
		* If we have a custom paper size, get the dimensions.
		
					case lnDefLength > 0 and file(lcLibrary)
						loForms = newobject('PrinterForms', lcLibrary)
						if vartype(loForms) <> 'O' or not empty(loForms.cErrorMessage)
							.cErrorMessage = 'ERR_NO_CONVERT.FLL'
						else
							loForms.GetPrinterForms()
							.cErrorMessage = loForms.cErrorMessage
							do case
		
		* The custom size was found, so get its dimensions.
		
								case between(.nPaperSize, 1, alen(loForms.aForms))
									lnWidth  = loForms.aForms[.nPaperSize].Size.cx
									lnLength = loForms.aForms[.nPaperSize].Size.cy
									if type('oLogger') = 'O'
										oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
											'custom paper size: width=' + transform(lnWidth) + ;
											', length=' + transform(lnLength))
									endif type('oLogger') = 'O'
		
		* The custom size wasn't found but we have a defined width, so use it.
		
								case .nCustomWidth <> 0
									lnWidth = -1
									if type('oLogger') = 'O'
										oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
											'paper size ' + transform(.nPaperSize) + ;
											' was not found; using set sizes ')
									endif type('oLogger') = 'O'
		
		* The custom size wasn't found so use the default sizes.
		
								otherwise
									lnWidth  = lnDefWidth
									lnLength = lnDefLength
									if type('oLogger') = 'O'
										oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
											'paper size ' + transform(.nPaperSize) + ;
											' was not found; using default sizes ')
									endif type('oLogger') = 'O'
							endcase
						endif vartype(loForms) <> 'O' ...
					case type('oLogger') = 'O'
						oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
							'did not get dimensions')
				endcase
			else
				if type('oLogger') = 'O'
					oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
						'could not read printer info')
				endif type('oLogger') = 'O'
			endif vartype(loPrinter) = 'O' ...
		
		* If a printer error occurred, assume 8.5 x 11.
		
			if lnWidth = 0
				lnWidth  = .aPaper[1, 1]
				lnLength = .aPaper[1, 2]
				if type('oLogger') = 'O'
					oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
						'no dimensions found. Using letter size. Error message = ' + ;
						.cErrorMessage)
				endif type('oLogger') = 'O'
			endif lnWidth = 0
		
		* Now subtract printer margins and round down to one decimal place; some
		* printers give a landscape width of 10.6667 but it should be 10.600.
		
			lnDecimals = set('DECIMALS')
			set decimals to 2
			lnWidth  = val(transform(lnWidth  - iif(.lWholePage, 0, lnHMargin), '99999.9'))
			lnLength = val(transform(lnLength - iif(.lWholePage, 0, lnVMargin), '99999.9'))
			set decimals to lnDecimals
		
		* If the report width is negative, meaning it's a defined value, and it's less
		* than the printer page width or we have an unfound custom paper size, use it
		* instead.
		
			lnPageWidth = abs(.nCustomWidth)/cnREPORT_UNITS
			if .nCustomWidth < 0 and (lnPageWidth < lnWidth or lnWidth < 0)
				lnWidth = lnPageWidth
				if type('oLogger') = 'O'
					oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: ' + ;
						'using defined paper width: ' + transform(lnPageWidth))
				endif type('oLogger') = 'O'
			endif .nCustomWidth < 0 ...
		
		* Set the minimum paper width.
		
			.nMinPaperWidth = lnWidth * cnREPORT_UNITS
		
		* If we're printing landscape and the paper is taller than wide, switch the
		* length and width.
		
			if tlLandscape and lnLength > lnWidth
				lnTemp   = lnWidth
				lnWidth  = lnLength
				lnLength = lnTemp
				.lUsingLandscape = .T.
			endif tlLandscape ...
			if type('oLogger') = 'O'
				oLogger.LogElapsedMilestone('SFReportFile.GetPaperWidth: width=' + ;
					transform(lnWidth) + ', length=' + transform(lnLength) + ;
					iif(.lUsingLandscape, ', using landscape', ''))
			endif type('oLogger') = 'O'
		
		* Save the dimensions.
		
			.nPaperWidth  = lnWidth  * cnREPORT_UNITS
			.nPaperLength = lnLength * cnREPORT_UNITS
		endwith
		return This.nPaperWidth
		
	ENDPROC

	PROTECTED PROCEDURE getprinterinfo		&& Returns printer information
		*==============================================================================
		* Method:			GetPrinterInfo
		* Purpose:			Returns printer information
		* Author:			Doug Hennig, adapted from code written by Sergey Berezniker:
		*http://www.berezniker.com/content/pages/visual-foxpro/determine-printer-margins-programmatically
		* Last revision:	11/19/2010
		* Parameters:		none
		* Returns:			an object with properties about the default printer, or
		*						NULL if there's a problem with the printer (e.g. no
		*						default printer)
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local lcPrinter, ;
			lnDC, ;
			lnPrintableAreaWidth, ;
			lnPrintableAreaHeight, ;
			lnPhysicalWidth, ;
			lnPhysicalHeight, ;
			lnPrinterMarginLeft, ;
			lnPrinterMarginTop
		
		* Declare the Windows API functions we need.
		
		declare long GetDeviceCaps in GDI32 long hDC, long nIndex
		declare long CreateDC in GDI32 string lpszDriver, string lpszDevice, ;
			long lpszOutput, long lpInitData
		declare long DeleteDC in GDI32 long hDC
		
		* Create an object to hold the results.
		
		loPrinter = createobject('Empty')
		addproperty(loPrinter, 'nPixelsPerInchY')
		addproperty(loPrinter, 'nPixelsPerInchX')
		addproperty(loPrinter, 'nPrintableAreaWidthInch')
		addproperty(loPrinter, 'nPrintableAreaHeightInch')
		addproperty(loPrinter, 'nPhysicalWidthInch')
		addproperty(loPrinter, 'nPhysicalHeightInch')
		addproperty(loPrinter, 'nPrinterMarginLeftInch')
		addproperty(loPrinter, 'nPrinterMarginTopInch')
		addproperty(loPrinter, 'nPrinterMarginBottomInch')
		addproperty(loPrinter, 'nPrinterMarginRightInch')
		
		* Get the default printer and create a device context.
		
		try
			lcPrinter = set('Printer', 3)
			lnDC      = CreateDC('', lcPrinter, 0, 0)
			with loPrinter
		
		* Determine the pixels per inch.
		
				.nPixelsPerInchY = GetDeviceCaps(lnDC, LOGPIXELSY)
				.nPixelsPerInchX = GetDeviceCaps(lnDC, LOGPIXELSX)
		
		* Get the printable area.
		
				lnPrintableAreaWidth      = GetDeviceCaps(lnDC, HORZRES)
				lnPrintableAreaHeight     = GetDeviceCaps(lnDC, VERTRES)
				.nPrintableAreaWidthInch  = lnPrintableAreaWidth/.nPixelsPerInchX
				.nPrintableAreaHeightInch = lnPrintableAreaHeight/.nPixelsPerInchY
		
		* Get the physical area.
		
				lnPhysicalWidth	     = GetDeviceCaps(lnDC, PHYSICALWIDTH)
				lnPhysicalHeight     = GetDeviceCaps(lnDC, PHYSICALHEIGHT)
				.nPhysicalWidthInch	 = lnPhysicalWidth/.nPixelsPerInchX
				.nPhysicalHeightInch = lnPhysicalHeight/.nPixelsPerInchY
		
		* Get the margins.
		
				lnPrinterMarginLeft	      = GetDeviceCaps(lnDC, PHYSICALOFFSETX)
				lnPrinterMarginTop	      = GetDeviceCaps(lnDC, PHYSICALOFFSETY)
				.nPrinterMarginLeftInch	  = lnPrinterMarginLeft/.nPixelsPerInchX
				.nPrinterMarginTopInch	  = lnPrinterMarginTop/.nPixelsPerInchY
				.nPrinterMarginBottomInch = .nPhysicalHeightInch - ;
					.nPrintableAreaHeightInch - .nPrinterMarginTopInch
				.nPrinterMarginRightInch  = .nPhysicalWidthInch - ;
					.nPrintableAreaWidthInch - .nPrinterMarginLeftInch
			endwith
		catch
			loPrinter = .NULL.
		finally
			DeleteDC(lnDC)
		endtry
		return loPrinter
		
	ENDPROC

	PROCEDURE getrelativevposition		&& Get the vertical position of the specified object relative to the start of its band
		lparameters toObject
		local lnSelect, ;
			lnVFactor
		lnSelect = select()
		select OBJECTS
		locate for UNIQUEID = toObject.cUniqueID
		select BANDS
		locate for UNIQUEID = OBJECTS.START_BAND_ID
		select (lnSelect)
		lnVFactor = This.GetVFactor(toObject)
		toObject.nVPosition = max((abs(toObject.nVPosition) - BANDS.START)/lnVFactor, 0)
		
	ENDPROC

	PROCEDURE getreportband		&& Returns an object reference to the specified band
		lparameters tcBand, ;
			tnNumber
		local lcBand, ;
			loBand, ;
			lnNumber, ;
			llOpen
		with This
			assert vartype(tcBand) = 'C' and inlist(upper(tcBand), ;
				ccBAND_PAGE_HEADER, ccBAND_PAGE_FOOTER, ccBAND_DETAIL, ccBAND_TITLE, ;
				ccBAND_SUMMARY, ccBAND_GROUP_HEADER, ccBAND_GROUP_FOOTER, ;
				ccBAND_COLUMN_HEADER, ccBAND_COLUMN_FOOTER, ccBAND_DETAIL_HEADER, ;
				ccBAND_DETAIL_FOOTER) ;
				message 'SFReportFile.GetReportBand: invalid tcBand parameter'
			assert pcount() = 1 or (vartype(tnNumber) $ 'NFIBY' and ;
				(between(tnNumber, 1, alen(.aGroupBands, 1)) or ;
				between(tnNumber, 1, alen(.aDetailBands, 1)))) ;
				message 'SFReportFile.GetReportBand: invalid tnNumber parameter'
			assert not inlist(upper(tcBand), ccBAND_COLUMN_HEADER, ;
				ccBAND_COLUMN_FOOTER) or .nColumns > 1 ;
				message 'SFReportFile.GetReportBand: not a columnar report'
			lcBand   = upper(tcBand)
			loBand   = .NULL.
			lnNumber = iif(vartype(tnNumber) $ 'NFIBY', tnNumber, 0)
			llOpen   = upper(.ClassLibrary) $ set('CLASSLIB')
			do case
				case lcBand = ccBAND_PAGE_HEADER
					loBand = .oPageHeaderBand
				case lcBand = ccBAND_PAGE_FOOTER
					loBand = .oPageFooterBand
				case lcBand = ccBAND_DETAIL_HEADER and lnNumber = 0
					loBand = .oDetailHeaderBand
				case lcBand = ccBAND_DETAIL_FOOTER and lnNumber = 0
					loBand = .oDetailFooterBand
				case lcBand = ccBAND_DETAIL and lnNumber = 0
					loBand = .oDetailBand
				case lcBand = ccBAND_DETAIL_HEADER
					loBand = .aDetailBands[lnNumber, 2]
				case lcBand = ccBAND_DETAIL_FOOTER
					loBand = .aDetailBands[lnNumber, 3]
				case lcBand = ccBAND_DETAIL
					loBand = .aDetailBands[lnNumber, 1]
				case lcBand = ccBAND_TITLE
					if .lTitleBand and isnull(.oTitleBand)
						if llOpen
							.oTitleBand = createobject('SFReportBand', 'Title', This)
						else
							.oTitleBand = newobject('SFReportBand', .ClassLibrary, ;
								'', 'Title', This)
						endif llOpen
					endif .lTitleBand ...
					loBand = .oTitleBand
				case lcBand = ccBAND_SUMMARY
					if .lSummaryBand and isnull(.oSummaryBand)
						if llOpen
							.oSummaryBand = createobject('SFReportBand', 'Summary', ;
								This)
						else
							.oSummaryBand = newobject('SFReportBand', .ClassLibrary, ;
								'', 'Summary', This)
						endif llOpen
					endif .lSummaryBand ...
					loBand = .oSummaryBand
				case lcBand = ccBAND_GROUP_HEADER
					loBand = .aGroupBands[lnNumber, 1]
				case lcBand = ccBAND_GROUP_FOOTER
					loBand = .aGroupBands[lnNumber, 2]
				case lcBand = ccBAND_COLUMN_HEADER
					loBand = .oColumnHeaderBand
				case lcBand = ccBAND_COLUMN_FOOTER
					loBand = .oColumnFooterBand
			endcase
		endwith
		return loBand
		
	ENDPROC

	PROCEDURE getvariable		&& Returns a variable object
		lparameters tcName
		local lcName, ;
			loReturn, ;
			lnI, ;
			loVariable
		lcName   = upper(tcName)
		loReturn = .NULL.
		for lnI = 1 to alen(This.aVariables)
			loVariable = This.aVariables[lnI]
			if vartype(loVariable) = 'O' and upper(loVariable.cName) == lcName
				loReturn = loVariable
				exit
			endif vartype(loVariable) = 'O' ...
		next lnI
		return loReturn
		
	ENDPROC

	PROCEDURE getvfactor		&& Calculates the vertical factor for the specified font
		lparameters toObject, ;
			tnLines
		local loObject, ;
			lnLines, ;
			lcStyle, ;
			lnFactor
		loObject = iif(type('toObject.cFontName') = 'C' and ;
			not empty(toObject.cFontName) and toObject.nFontSize > 0, toObject, This)
		lnLines  = iif(vartype(tnLines) = 'N' and tnLines > 0, tnLines, 1)
		if loObject.nFontStyle >= 0
			lcStyle  = iif(bittest(loObject.nFontStyle, cnSTYLE_BOLD_BIT), 'B', '') + ;
				iif(bittest(loObject.nFontStyle, cnSTYLE_ITALIC_BIT), 'I', '')
		else
			lcStyle  = iif(loObject.lFontBold, 'B', '') + ;
				iif(loObject.lFontItalic, 'I', '')
		endif loObject.nFontStyle >= 0
		lnFactor = (fontmetric(1, loObject.cFontName, loObject.nFontSize, lcStyle) + ;
			cnVERTICAL_FUDGE/lnLines) * cnFACTOR
		return lnFactor
		
	ENDPROC

	PROCEDURE getvvalue		&& Calculates a vertical values in the units used by the report
		lparameters tnValue, ;
			toObject
		local lnValue
		with This
			if .cUnits = ccUNITS_CHARACTERS
				lnValue = tnValue
			else
				lnValue = tnValue * .GetVFactor(toObject)/cnREPORT_UNITS
			endif .cUnits = ccUNITS_CHARACTERS
		endwith
		return lnValue
		
	ENDPROC

	PROCEDURE Init
		local loException as Exception, ;
			llOpen
		
		* Create the objects representing bands in every report and the DE.
		
		with This
			llOpen = upper(.ClassLibrary) $ set('CLASSLIB')
			if llOpen
				.oPageHeaderBand = createobject('SFReportBand', 'Page Header', This)
				.oDetailBand     = createobject('SFReportBand', 'Detail',      This)
				.oPageFooterBand = createobject('SFReportBand', 'Page Footer', This)
				.oDE             = createobject('SFReportDE')
			else
				.oPageHeaderBand = newobject('SFReportBand', .ClassLibrary, '', ;
					'Page Header', This)
				.oDetailBand     = newobject('SFReportBand', .ClassLibrary, '', ;
					'Detail',      This)
				.oPageFooterBand = newobject('SFReportBand', .ClassLibrary, '', ;
					'Page Footer', This)
				.oDE             = newobject('SFReportDE', .ClassLibrary)
			endif llOpen
			dimension .aGroupBands[1, 2]
			dimension .aDetailBands[1, 3]
			.aGroupBands  = .NULL.
			.aDetailBands = .NULL.
			.aVariables   = .NULL.
		
		* Set the horizontal and vertical factors we'll work with.
		
			.SetVHFactors()
		
		* Fill an array with paper dimensions (see https://docs.microsoft.com/en-us/windows/win32/intl/paper-sizes)
		
			dimension .aPaper[70, 2]
			.aPaper[ 1, 1] = 8.5
			.aPaper[ 1, 2] = 11
			.aPaper[ 2, 1] = 8.5
			.aPaper[ 2, 2] = 11
			.aPaper[ 3, 1] = 11
			.aPaper[ 3, 2] = 17
			.aPaper[ 4, 1] = 17
			.aPaper[ 4, 2] = 11
			.aPaper[ 5, 1] = 8.5
			.aPaper[ 5, 2] = 14
			.aPaper[ 6, 1] = 5.5
			.aPaper[ 6, 2] = 8.5
			.aPaper[ 7, 1] = 7.25
			.aPaper[ 7, 2] = 10.5
			.aPaper[ 8, 1] = 297/cnDEFAULT_PRTINFO_MM
			.aPaper[ 8, 2] = 420/cnDEFAULT_PRTINFO_MM
			.aPaper[ 9, 1] = 210/cnDEFAULT_PRTINFO_MM
			.aPaper[ 9, 2] = 297/cnDEFAULT_PRTINFO_MM
			.aPaper[10, 1] = 210/cnDEFAULT_PRTINFO_MM
			.aPaper[10, 2] = 297/cnDEFAULT_PRTINFO_MM
			.aPaper[11, 1] = 148/cnDEFAULT_PRTINFO_MM
			.aPaper[11, 2] = 210/cnDEFAULT_PRTINFO_MM
			.aPaper[12, 1] = 250/cnDEFAULT_PRTINFO_MM
			.aPaper[12, 2] = 354/cnDEFAULT_PRTINFO_MM
			.aPaper[13, 1] = 182/cnDEFAULT_PRTINFO_MM
			.aPaper[13, 2] = 257/cnDEFAULT_PRTINFO_MM
			.aPaper[14, 1] = 8.5
			.aPaper[14, 2] = 13
			.aPaper[15, 1] = 215/cnDEFAULT_PRTINFO_MM
			.aPaper[15, 2] = 275/cnDEFAULT_PRTINFO_MM
			.aPaper[16, 1] = 10
			.aPaper[16, 2] = 14
			.aPaper[17, 1] = 11
			.aPaper[17, 2] = 17
			.aPaper[18, 1] = 8.5
			.aPaper[18, 2] = 11
			.aPaper[19, 1] = 3.87
			.aPaper[19, 2] = 8.87
			.aPaper[20, 1] = 4.12
			.aPaper[20, 2] = 9.5
			.aPaper[21, 1] = 4.5
			.aPaper[21, 2] = 10.37
			.aPaper[22, 1] = 4.5
			.aPaper[22, 2] = 11
			.aPaper[23, 1] = 5
			.aPaper[23, 2] = 11.5
			.aPaper[24, 1] = cnDEFAULT_REPORT_WIDTH
			.aPaper[24, 2] = cnDEFAULT_REPORT_LENGTH
			.aPaper[25, 1] = cnDEFAULT_REPORT_WIDTH
			.aPaper[25, 2] = cnDEFAULT_REPORT_LENGTH
			.aPaper[26, 1] = cnDEFAULT_REPORT_WIDTH
			.aPaper[26, 2] = cnDEFAULT_REPORT_LENGTH
			.aPaper[27, 1] = 110/cnDEFAULT_PRTINFO_MM
			.aPaper[27, 2] = 220/cnDEFAULT_PRTINFO_MM
			.aPaper[28, 1] = 162/cnDEFAULT_PRTINFO_MM
			.aPaper[28, 2] = 229/cnDEFAULT_PRTINFO_MM
			.aPaper[29, 1] = 324/cnDEFAULT_PRTINFO_MM
			.aPaper[29, 2] = 458/cnDEFAULT_PRTINFO_MM
			.aPaper[30, 1] = 229/cnDEFAULT_PRTINFO_MM
			.aPaper[30, 2] = 324/cnDEFAULT_PRTINFO_MM
			.aPaper[31, 1] = 114/cnDEFAULT_PRTINFO_MM
			.aPaper[31, 2] = 162/cnDEFAULT_PRTINFO_MM
			.aPaper[32, 1] = 114/cnDEFAULT_PRTINFO_MM
			.aPaper[32, 2] = 229/cnDEFAULT_PRTINFO_MM
			.aPaper[33, 1] = 250/cnDEFAULT_PRTINFO_MM
			.aPaper[33, 2] = 353/cnDEFAULT_PRTINFO_MM
			.aPaper[34, 1] = 176/cnDEFAULT_PRTINFO_MM
			.aPaper[34, 2] = 250/cnDEFAULT_PRTINFO_MM
			.aPaper[35, 1] = 176/cnDEFAULT_PRTINFO_MM
			.aPaper[35, 2] = 125/cnDEFAULT_PRTINFO_MM
			.aPaper[36, 1] = 110/cnDEFAULT_PRTINFO_MM
			.aPaper[36, 2] = 230/cnDEFAULT_PRTINFO_MM
			.aPaper[37, 1] = 3.87
			.aPaper[37, 2] = 7.5
			.aPaper[38, 1] = 3.62
			.aPaper[38, 2] = 6.5
			.aPaper[39, 1] = 14.87
			.aPaper[39, 2] = 11
			.aPaper[40, 1] = 8.5
			.aPaper[40, 2] = 12
			.aPaper[41, 1] = 8.5
			.aPaper[41, 2] = 13
			.aPaper[42, 1] = 250/cnDEFAULT_PRTINFO_MM
			.aPaper[42, 2] = 353/cnDEFAULT_PRTINFO_MM
			.aPaper[43, 1] = 100/cnDEFAULT_PRTINFO_MM
			.aPaper[43, 2] = 148/cnDEFAULT_PRTINFO_MM
			.aPaper[44, 1] = 9
			.aPaper[44, 2] = 11
			.aPaper[45, 1] = 10
			.aPaper[45, 2] = 11
			.aPaper[46, 1] = 15
			.aPaper[46, 2] = 11
			.aPaper[47, 1] = 220/cnDEFAULT_PRTINFO_MM
			.aPaper[47, 2] = 220/cnDEFAULT_PRTINFO_MM
			.aPaper[48, 1] = 0
			.aPaper[48, 2] = 0
			.aPaper[49, 1] = 0
			.aPaper[49, 2] = 0
			.aPaper[50, 1] = 9.5
			.aPaper[50, 2] = 12
			.aPaper[51, 1] = 9.5
			.aPaper[51, 2] = 15
			.aPaper[52, 1] = 11.69
			.aPaper[52, 2] = 18
			.aPaper[53, 1] = 9.27
			.aPaper[53, 2] = 12.69
			.aPaper[54, 1] = 8.5
			.aPaper[54, 2] = 11
			.aPaper[55, 1] = 210/cnDEFAULT_PRTINFO_MM
			.aPaper[55, 2] = 297/cnDEFAULT_PRTINFO_MM
			.aPaper[56, 1] = 9.5
			.aPaper[56, 2] = 12
			.aPaper[57, 1] = 227/cnDEFAULT_PRTINFO_MM
			.aPaper[57, 2] = 356/cnDEFAULT_PRTINFO_MM
			.aPaper[58, 1] = 305/cnDEFAULT_PRTINFO_MM
			.aPaper[58, 2] = 487/cnDEFAULT_PRTINFO_MM
			.aPaper[59, 1] = 8.5
			.aPaper[59, 2] = 12.69
			.aPaper[60, 1] = 210/cnDEFAULT_PRTINFO_MM
			.aPaper[60, 2] = 330/cnDEFAULT_PRTINFO_MM
			.aPaper[61, 1] = 148/cnDEFAULT_PRTINFO_MM
			.aPaper[61, 2] = 210/cnDEFAULT_PRTINFO_MM
			.aPaper[62, 1] = 182/cnDEFAULT_PRTINFO_MM
			.aPaper[62, 2] = 257/cnDEFAULT_PRTINFO_MM
			.aPaper[63, 1] = 322/cnDEFAULT_PRTINFO_MM
			.aPaper[63, 2] = 445/cnDEFAULT_PRTINFO_MM
			.aPaper[64, 1] = 174/cnDEFAULT_PRTINFO_MM
			.aPaper[64, 2] = 235/cnDEFAULT_PRTINFO_MM
			.aPaper[65, 1] = 201/cnDEFAULT_PRTINFO_MM
			.aPaper[65, 2] = 276/cnDEFAULT_PRTINFO_MM
			.aPaper[66, 1] = 420/cnDEFAULT_PRTINFO_MM
			.aPaper[66, 2] = 594/cnDEFAULT_PRTINFO_MM
			.aPaper[67, 1] = 297/cnDEFAULT_PRTINFO_MM
			.aPaper[67, 2] = 420/cnDEFAULT_PRTINFO_MM
			.aPaper[68, 1] = 322/cnDEFAULT_PRTINFO_MM
			.aPaper[68, 2] = 445/cnDEFAULT_PRTINFO_MM
			.aPaper[69, 1] = 200/cnDEFAULT_PRTINFO_MM
			.aPaper[69, 2] = 148/cnDEFAULT_PRTINFO_MM
			.aPaper[70, 1] = 105/cnDEFAULT_PRTINFO_MM
			.aPaper[70, 2] = 148/cnDEFAULT_PRTINFO_MM
		
		* Set the default paper size.
		
			try
				.nPaperSize = prtinfo(2)
			catch to loException
				.nPaperSize = 1
			endtry
		endwith
		dodefault()
		
	ENDPROC

	PROTECTED PROCEDURE insertband		&& Inserts the specified band record into the report
		lparameters toBand
		local loRecord
		if not isnull(toBand)
			with This
				loRecord = .CreateReportRecord()
				toBand.CreateRecord(loRecord, This)
				.InsertRecord(loRecord, toBand)
			endwith
		endif not isnull(toBand)
		return
		
	ENDPROC

	PROTECTED PROCEDURE insertbandobjects		&& Inserts records for the objects in the specified band into the report
		lparameters toBand
		local lnHeight, ;
			lnMaxHeight, ;
			lnMaxWidth, ;
			laObjects[1], ;
			lnObjects, ;
			laBottom[1], ;
			lnI, ;
			loObject, ;
			lnBottom, ;
			lnGroup, ;
			lnNewHeight, ;
			llAdjustWidth
		if not isnull(toBand)
			with This
		
		* Handle each object in the band: add a record for the object.
		
				go toBand.Recno
				store HEIGHT to lnHeight, lnMaxHeight
				lnMaxWidth = .nRepWidth
				lnObjects  = toBand.GetReportObjects(@laObjects, , .T.)
				dimension laBottom[99]
				laBottom = 0
				for lnI = 1 to lnObjects
					loObject = .CreateReportRecord()
					laObjects[lnI].CreateRecord(loObject, This)
					.InsertRecord(loObject, laObjects[lnI])
		
		* If we're supposed to bottom align to this object in this row, save the bottom
		* position of the object.
		
					if '#BOTTOMALIGNTO' $ USER
						lnBottom = val(right(USER, 2))
						laBottom[lnBottom] = loObject.VPos + loObject.Height
					endif '#BOTTOMALIGNTO' $ USER
		
		* Handle grouped objects.
		
		*** TODO: need to ensure that grouped objects are consecutive!!!
					lnGroup = laObjects[lnI].nGroup
					if lnGroup > 0
						if alen(.aObjectGroups) < lnGroup or empty(.aObjectGroups[1])
							dimension .aObjectGroups[lnGroup, 2]
							.aObjectGroups[lnGroup, 1] = laObjects[lnI].Recno - .nFirstObject + 1
							.aObjectGroups[lnGroup, 2] = 0
						endif alen(.aObjectGroups) < lnGroup
						.aObjectGroups[lnGroup, 2] = .aObjectGroups[lnGroup, 2] + 1
					endif lnGroup > 0 ...
		
		* If we're not allowed to adjust the band height, drop any objects outside the
		* band.
		
					lnNewHeight   = loObject.VPos - .nHeight - ;
						.nBand * cnBAND_HEIGHT + loObject.Height
					llAdjustWidth = .T.
					do case
						case toBand.lAdjustBandHeight
							lnMaxHeight = max(lnMaxHeight, lnNewHeight)
						case lnNewHeight > lnMaxHeight and ;
							toBand.lDeleteObjectsOutsideBand
							delete
							llAdjustWidth = .F.
					endcase
					if llAdjustWidth
						lnMaxWidth = max(lnMaxWidth, loObject.HPos + loObject.Width)
					endif llAdjustWidth
				next lnI
		
		* If we're bottom-aligning objects, do so.
		
				if laBottom[1] > 0
					for lnI = 1 to lnObjects
						if '#BOTTOMALIGN' $ laObjects[lnI].cUser
							lnBottom = val(right(laObjects[lnI].cUser, 2))
							go laObjects[lnI].Recno
							replace VPOS with laBottom[lnBottom] - HEIGHT
						endif '#BOTTOMALIGN' $ laObjects[lnI].cUser
					next lnI
				endif laBottom[1] > 0
		
		* If the band height isn't sufficient, adjust it if we're allowed to.
		
				if lnMaxHeight > lnHeight and toBand.lAdjustBandHeight
					go toBand.Recno
					replace HEIGHT with lnMaxHeight
				else
					lnMaxHeight = lnHeight
				endif lnMaxHeight > lnHeight ...
		
		* Increment the current band number and height, and set the report width.
		
				.nBand     = .nBand + 1
				.nHeight   = .nHeight + lnMaxHeight
				.nRepWidth = lnMaxWidth
			endwith
		endif not isnull(toBand)
		return
		
	ENDPROC

	PROTECTED PROCEDURE insertde		&& Inserts a DataEnvironment record into the report
		local loRecord
		with This
			loRecord = .CreateReportRecord()
			.oDE.lPrivateDataSession = .lPrivateDataSession
			.oDE.CreateRecord(loRecord, This)
			.InsertRecord(loRecord)
		endwith
		return
		
	ENDPROC

	PROTECTED PROCEDURE insertheader		&& Inserts a header record into the report
		local loRecord, ;
			lnProtection
		with This
			loRecord         = .CreateReportRecord()
			loRecord.ObjType = cnREPOBJ_HEADER
			loRecord.ObjCode = cnREPOBJ_CODE_HEADER
			loRecord.VPos    = .nColumns
			loRecord.HPos    = iif(.nLeftMargin < 0, -.nLeftMargin, ;
				.nLeftMargin * .nHFactor)
			loRecord.Height  = iif(.nColumnSpacing < 0, -.nColumnSpacing, ;
				.nColumnSpacing * .nHFactor)
			do case
				case not .lSetHeaderWidth
					loRecord.Width = -1
				case .nWidth < 0
					loRecord.Width = -.nWidth
				otherwise
					loRecord.Width = .nWidth * .nHFactor
			endcase
			loRecord.FontFace   = .cFontName
			loRecord.FontSize   = .nFontSize
			loRecord.FontStyle  = .nFontStyle
			loRecord.Top        = .lWholePage
			loRecord.Bottom     = .lPrintColumns
			loRecord.Ruler      = .nRulerScale
			loRecord.RulerLines = 1
			loRecord.Grid       = .T.
			loRecord.GridV      = 5
			loRecord.GridH      = 5
			loRecord.AddAlias   = .T.
			loRecord.CurPos     = .T.
			loRecord.Style      = .cMemberData
			loRecord.Double     = .T.
			lnProtection        = iif(.lNoDataEnvironment, ;
					2^FRX_PROTECT_REPORT_NO_DATAENV, 0) + ;
				iif(.lNoQuickReport, 2^FRX_PROTECT_REPORT_NO_QUICKREPORT, 0) + ;
				iif(.lNoPreview, 2^FRX_PROTECT_REPORT_NO_PREVIEW + ;
					2^FRX_PROTECT_REPORT_NO_PRINT, 0)
			if lnProtection <> 0
				loRecord.Order = bintoc(lnProtection, 'RS')
			endif lnProtection <> 0
			.InsertRecord(loRecord)
		endwith
		return
		
	ENDPROC

	PROTECTED PROCEDURE insertobjectgroup		&& Inserts a record for an object group
		lparameters tnIndex, ;
			tnCount
		local loRecord
		with This
			loRecord         = .CreateReportRecord()
			loRecord.ObjType = cnREPOBJ_CODE_GROUP
			loRecord.VPos    = tnIndex
			loRecord.HPos    = tnCount
			.InsertRecord(loRecord)
		endwith
		return
		
	ENDPROC

	PROTECTED PROCEDURE insertrecord		&& Inserts the specified record to the report file
		* Adjust certain properties of the specified record, then add it to the report
		* file.
		
		lparameters toRecord, ;
			toObject
		local lcRender, ;
			lcExpr, ;
			lcValue
		with This
			if not inlist(toRecord.ObjType, cnREPOBJ_HEADER, cnREPOBJ_VARIABLE, ;
				cnREPOBJ_FONT, cnREPOBJ_DATA_ENVIRONMENT, cnREPOBJ_DATA_OBJECT, ;
				cnREPOBJ_CODE_GROUP)
		
		* Convert the height, width, left, and top properties of the object to report
		* units. Note that if these values are negative, they contain the value in FRUs
		* so make them positive.
		
				toRecord.Height = iif(toRecord.Height <= 0, -toRecord.Height, ;
					round(max(toRecord.Height * .nVFactor, cnFACTOR), 0))
				if toRecord.ObjType <> cnREPOBJ_BAND
					toRecord.Width = iif(toRecord.Width < 0, -toRecord.Width, ;
						(toRecord.Width + iif(toRecord.ObjType = cnREPOBJ_FIELD, ;
						cnWIDTH_FUDGE, 0)) * .nHFactor)
					if toRecord.HPos < 0
						toRecord.HPos = - toRecord.HPos
					else
						toRecord.HPos = toRecord.HPos * .nHFactor
					endif toRecord.HPos < 0
					if toRecord.VPos < 0
						toRecord.VPos = - toRecord.VPos
					else
						toRecord.VPos = toRecord.VPos * .nVFactor + .nHeight + ;
							.nBand * cnBAND_HEIGHT
		
		* If we're working in characters and the object is less than a full line high,
		* let's center it vertically on the line.
		
						if .cUnits = ccUNITS_CHARACTERS and toRecord.Height < .nVFactor and ;
							vartype(toObject) = 'O' and toObject.lAutoCenter
							toRecord.VPos = toRecord.VPos + ;
								(.nVFactor - toRecord.Height)/2
						endif .cUnits = ccUNITS_CHARACTERS ...
					endif toRecord.VPos < 0
		
		* Handle the "width" for a band (which is really for widow control).
		
				else
					toRecord.Width = iif(toRecord.Width < 0, -toRecord.Width, ;
						round(max(toRecord.Width * .nVFactor, cnFACTOR), 0))
				endif toRecord.ObjType <> cnREPOBJ_BAND
			endif not inlist(toRecord.ObjType, ...
		
		* Add the record to the report file.
		
			append blank
			gather name toRecord memo
			if vartype(toObject) = 'O'
				toObject.Recno = recno()
			endif vartype(toObject) = 'O'
		
		* If the USER memo contains a post-insert "textmerge", do so now. This is
		* likely because we want the FRX record number.
		
			if '#RENDER' $ USER
				lcRender = strextract(USER, '#RENDER=', '#', 1, 5)
				lcExpr   = strextract(USER, '#RENDER=', '#', 1, 1)
				lcValue  = evaluate(lcExpr)
				replace USER with strtran(USER, lcRender, lcValue)
			endif '#RENDER' $ USER
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE inserttrailer		&& Inserts a trailer record into the report
		local lnFontStyle, ;
			lcFontStyle, ;
			loRecord
		with This
			loRecord          = .CreateReportRecord()
			loRecord.ObjType  = cnREPOBJ_FONT
			loRecord.VPos     = fontmetric(1, .cFontName, .nFontSize) + ;
				fontmetric(5, .cFontName, .nFontSize)
			loRecord.HPos     = fontmetric(6, .cFontName, .nFontSize)
			loRecord.Height   = fontmetric(2, .cFontName, .nFontSize)
			loRecord.Width    = fontmetric(7, .cFontName, .nFontSize)
			loRecord.PenRed   = cnPEN_RED_FUDGE
			loRecord.FontFace = .cFontName
			loRecord.FontSize = .nFontSize
			.InsertRecord(loRecord)
		endwith
		return
		
	ENDPROC

	PROTECTED PROCEDURE insertvariable		&& Inserts a report variable into the report
		lparameters toVariable
		local loRecord
		if not isnull(toVariable)
			with This
				loRecord = .CreateReportRecord()
				toVariable.CreateRecord(loRecord, This)
				.InsertRecord(loRecord, toVariable)
			endwith
		endif not isnull(toBand)
		return
		
	ENDPROC

	PROCEDURE llandscape_assign
		lparameter tlValue
		with This
			.lLandscape   = tlValue
			.nOrientation = iif(tlValue, cnORIENTATION_LANDSCAPE, ;
				cnORIENTATION_PORTRAIT)
		endwith
		
	ENDPROC

	PROCEDURE load		&& Loads the specified FRX into report objects
		lparameters tcReportFile
		local lcReportFile
		
		* Ensure a report file was specified and it exists.
		
		lcReportFile = iif(vartype(tcReportFile) <> 'C' or empty(tcReportFile), ;
			This.cReportFile, tcReportFile)
		if empty(lcReportFile)
			if type('oLocalizer') = 'O'
				error oLocalizer.GetLocalizedString('ERR_NO_REPORT_FILE')
			else
				error 'The name of the report file was not specified.'
			endif type('oLocalizer') = 'O'
			return .F.
		endif empty(lcReportFile)
		if not file(lcReportFile)
			error cnERR_FILE_NOT_FOUND, lcReportFile
			return .F.
		endif not file(lcReportFile)
		
		* Open the FRX and have LoadFromCursor do the dirty work.
		
		lnSelect = select()
		select 0
		use (lcReportFile) again shared alias FRX
		This.LoadFromCursor()
		use
		select (lnSelect)
		return
		
	ENDPROC

	PROCEDURE loadfromcursor		&& Loads the FRX in the current work area into report objects
		local loFRXCursor, ;
			lnBands, ;
			lnGroups, ;
			llSortBands, ;
			llOpen, ;
			lnHeight, ;
			lnWidth, ;
			lnHPos, ;
			lcBand, ;
			lnBand, ;
			loBand, ;
			lnTotHeight, ;
			lnVPos, ;
			lcPaperSize, ;
			lcDefaultSource, ;
			lcDevice, ;
			lcTag, ;
			lcTag2, ;
			laBands[1], ;
			loObject, ;
			laObjects[reccount()], ;
			lnFirst, ;
			lnCount, ;
			lnRecno, ;
			lnI
		with This
		
		* Ensure a report file is open.
		
			if empty(alias())
				if type('oLocalizer') = 'O'
					error oLocalizer.GetLocalizedString('ERR_NO_REPORT_FILE')
				else
					error 'The name of the report file was not specified.'
				endif type('oLocalizer') = 'O'
				return .F.
			endif empty(alias())
		
		* Set the horizontal and vertical factors we'll work with.
		
			.SetVHFactors()
		
		* Create OBJECTS and BANDS cursors to help decide what band each object
		* belongs to.
		
			if file('_FRXCursor.vcx')
				loFRXCursor = newobject('FRXCursor', '_FRXCursor.vcx')
			else
				loFRXCursor = newobject('FRXCursor', home() + 'FFC\_FRXCursor.vcx')
			endif file('_FRXCursor.vcx')
			loFRXCursor.ScreenDPI = cnSCREEN_DPI
			loFRXCursor.CreateObjectCursor()
		
		* Process each record in the FRX.
		
			lnBands     = 0
			lnGroups    = 0
			llSortBands = .F.
			llOpen      = upper(.ClassLibrary) $ set('CLASSLIB')
			scan for PLATFORM = 'WINDOWS'
		
		* Convert the height, width, and horizontal position into negative values so
		* we use absolute units. Vertical position will be calculated based on the
		* object's position within the band.
		
				lnHeight = -Height
				lnWidth  = -Width
				lnHPos   = -HPos
		
		* For certain types of objects, figure out which band it goes in by checking
		* the objects and bands cursors, then adjust the vertical position so it's
		* relative to the start of the band.
		
				if inlist(ObjType, cnREPOBJ_TEXT, cnREPOBJ_FIELD, cnREPOBJ_LINE, ;
					cnREPOBJ_BOX, cnREPOBJ_IMAGE)
					select OBJECTS
					locate for UNIQUEID = FRX.UNIQUEID
					lcBand = START_BAND_ID
					lnBand = ascan(laBands, lcBand, -1, -1, 1, 15)
					if lnBand > 0
						loBand = laBands[lnBand, 2]
						select BANDS
						locate for UNIQUEID = lcBand
						lnTotHeight = START
						select FRX
						lnVPos = max((VPos - lnTotHeight)/.nVFactor, 0)
		
		* We have a problem: we can't figure out which band the object belongs to.
		* Dump the FRX for diagnostics.
		
					else
						strtofile(FRX.UNIQUEID, addbs(sys(2023)) + 'Diagnostic.txt')
						copy to addbs(sys(2023)) + 'Objects'
						select FRX
						copy to addbs(sys(2023)) + 'Diagnostic.FRX'
						loop
					endif lnBand > 0
				endif inlist(ObjType ...
		*** TODO: handle protection flags on all objects. Read from ORDER and split into diff components
				do case
		
		* Get information about the report from the report header record.
		
					case ObjType = cnREPOBJ_HEADER
						lcPaperSize = strextract(Expr, 'PAPERSIZE=', ccLF)
						if not empty(lcPaperSize)
							.nPaperSize = val(lcPaperSize)
						endif not empty(lcPaperSize)
						.nLeftMargin    = HPos
						.nColumnSpacing = Height
						.lWholePage     = Top
						.lPrintColumns  = Bottom
						.nOrientation   = iif ('ORIENTATION=1' $ EXPR, ;
							cnORIENTATION_LANDSCAPE, 0)
						.nColumns       = VPos
						if .lSetHeaderWidth
							.nWidth = lnWidth
						endif .lSetHeaderWidth
						.cFontName   = iif(empty(FontFace), .cFontName, FontFace)
						.nFontSize   = iif(empty(FontSize), .nFontSize, FontSize)
						.nFontStyle  = FontStyle
						.cMemberData = Style
						.nRulerScale = Ruler
						lcDefaultSource = strextract(Expr, 'DEFAULTSOURCE=', ccLF)
						if not empty(lcDefaultSource)
							.nDefaultSource = val(lcDefaultSource)
						endif not empty(lcDefaultSource)
						lcDevice = strextract(Expr, 'DEVICE=', ccLF)
						lcTag    = strconv(Tag,  14)
						lcTag2   = strconv(Tag2, 14)
						if not empty(lcDevice)
							.cDevice = lcDevice
							.cTag    = lcTag
							.cTag2   = lcTag2
						endif not empty(lcDevice)
		
		*** TODO: The following values are hard-coded in InsertHeader -- read them from FRX?
		*.RulerLines, .Grid, .GridV, .GridH, .AddAlias, .CurPos
		*** TODO: other things to handle:
		* PICTURE may contain printer settings that override EXPR
		* ADDALIAS: lAddAlias
		* PLAIN: lAddNonSelectedALias
		* DOUBLE: if .T., RESOID contains FontCharSet for default font
		
		* Handle a band record.
						
					case ObjType = cnREPOBJ_BAND
						do case
		
		* If this is the title band, flag that we have one and create an object for it.
		
							case ObjCode = cnREPOBJ_CODE_TITLE
								.lTitleBand = .T.
								if llOpen
									.oTitleBand = createobject('SFReportBand', ;
										'Title', This)
								else
									.oTitleBand = newobject('SFReportBand', ;
										.ClassLibrary, '', 'Title', This)
								endif llOpen
								loBand = .oTitleBand
		
		* If this is the summary band, flag that we have one, create an object for it,
		* and set some properties.
		
							case ObjCode = cnREPOBJ_CODE_SUMMARY
								.lSummaryBand = .T.
								if llOpen
									.oSummaryBand = createobject('SFReportBand', ;
										'Summary', This)
								else
									.oSummaryBand = newobject('SFReportBand', ;
										.ClassLibrary, '', 'Summary', This)
								endif llOpen
								loBand = .oSummaryBand
		
		* In the case of page header, page footer, and detail band records, just grab
		* a reference to the existing object.
		
							case ObjCode = cnREPOBJ_CODE_PGHEADER
								loBand = .oPageHeaderBand
							case ObjCode = cnREPOBJ_CODE_PGFOOTER
								loBand = .oPageFooterBand
							case ObjCode = cnREPOBJ_CODE_DETAIL
								loBand = .oDetailBand
		
		* Handle detail header and footer bands.
		
							case ObjCode = cnREPOBJ_CODE_DETHEADER
								if llOpen
									.oDetailHeaderBand = createobject('SFReportBand', ;
										'Detail Header', This)
									.oDetailFooterBand = createobject('SFReportBand', ;
										'Detail Footer', This)
								else
									.oDetailHeaderBand = newobject('SFReportBand', ;
										.ClassLibrary, '', 'Detail Header', This)
									.oDetailFooterBand = newobject('SFReportBand', ;
										.ClassLibrary, '', 'Detail Footer', This)
								endif llOpen
								loBand = .oDetailHeaderBand
							case ObjCode = cnREPOBJ_CODE_DETFOOTER
								loBand = .oDetailFooterBand
		
		* If this is a group header band, create it and the detail band objects, then
		* grab the reference.
		
							case ObjCode = cnREPOBJ_CODE_GPHEADER
								.CreateGroupBand()
								loBand = .GetReportBand(ccBAND_GROUP_HEADER, ;
									alen(.aGroupBands, 1))
		
		* If this is a group footer band, an object for it should already exist, so
		* grab the reference.
		
		*** TODO: how do we know which group number to get???
							case ObjCode = cnREPOBJ_CODE_GPFOOTER
								loBand = .GetReportBand(ccBAND_GROUP_FOOTER, ;
									alen(.aGroupBands, 1))
						endcase
		
		* Now that we have a reference to the band, set its properties.
		
						loBand.ReadFromFRX()
						loBand.nHeight = Height/This.nVFactor
		
		* Save information about the band in the band array.
		
						lnBands = lnBands + 1
						dimension laBands[lnBands, 2]
						laBands[lnBands, 1] = UNIQUEID
						laBands[lnBands, 2] = loBand
		
		* If this is a variable, create it and the detail band objects, then
		* grab the reference.
		
					case ObjType = cnREPOBJ_VARIABLE
						loObject = .CreateVariable()
						loObject.ReadFromFRX()
		
		* Handle a text, field, line, box, and image objects.
						
					case inlist(ObjType, cnREPOBJ_TEXT, cnREPOBJ_FIELD, ;
						cnREPOBJ_LINE, cnREPOBJ_BOX, cnREPOBJ_IMAGE)
						do case
							case ObjType = cnREPOBJ_TEXT
								loObject = loBand.Add('Text')
							case ObjType = cnREPOBJ_FIELD
								loObject = loBand.Add('Field')
							case ObjType = cnREPOBJ_LINE
								loObject = loBand.Add('Line')
							case ObjType = cnREPOBJ_BOX
								loObject = loBand.Add('Box')
							case ObjType = cnREPOBJ_IMAGE
								loObject = loBand.Add('Image')
						endcase
						loObject.ReadFromFRX()
						loObject.nVPosition = lnVPos
						laObjects[recno()] = loObject
		
		* Handle grouped objects.
		
					case ObjType = cnREPOBJ_CODE_GROUP
						lnGroups = lnGroups + 1
						lnFirst  = VPOS
						lnCount  = HPOS
						lnRecno  = recno()
						locate for not inlist(OBJTYPE, cnREPOBJ_HEADER, cnREPOBJ_BAND)
						skip lnFirst - 1
						for lnI = 1 to lnCount
							if vartype(laObjects[recno()]) = 'O'
								laObjects[recno()].nGroup = lnGroups
							endif vartype(laObjects[recno()]) = 'O'
							skip
						next lnI
						go lnRecno
		
		*** TODO: any other types to handle? eg. handle de (25) and def values (23) records???
				endcase
			endscan for PLATFORM = 'WINDOWS'
		
		* Close the BANDS and OBJECTS cursors.
		
			use in BANDS
			use in OBJECTS
		endwith
		
	ENDPROC

	PROCEDURE lwholepage_assign
		* If lWholePage is changed, adjust lLeftMargin by half the printer margin
		* (that's what the Report Designer does in the Page Setup dialog).
		
		lparameter tlValue
		local lnAdjust
		with This
			if tlValue <> .lWholePage
				.lWholePage  = tlValue
				do case
					case .cUnits = ccUNITS_INCHES
						lnAdjust = cnPRINTER_MARGIN
					case .cUnits = ccUNITS_CENTIMETERS
						lnAdjust = cnPRINTER_MARGIN * 2.54
					otherwise
						lnAdjust = cnPRINTER_MARGIN * cnREPORT_UNITS/.nHFactor
				endcase
				.nLeftMargin = .nLeftMargin + iif(tlValue, 1, -1) * lnAdjust/2
			endif tlValue <> .lWholePage
		endwith
		
	ENDPROC

	PROCEDURE ncolumnspacing_assign
		lparameter tnValue
		This.nColumnSpacing = tnValue
		This.SetColumnWidth()
		
	ENDPROC

	PROCEDURE ncolumns_assign
		lparameter tnValue
		with This
			.nColumns = tnValue
			do case
				case tnValue > 1 and vartype(.oColumnHeaderBand) <> 'O'
					if upper(.ClassLibrary) $ set('CLASSLIB')
						.oColumnHeaderBand = createobject('SFReportBand', ;
							'Column Header', This)
						.oColumnFooterBand = createobject('SFReportBand', ;
							'Column Footer', This)
					else
						.oColumnHeaderBand = newobject('SFReportBand', .ClassLibrary, ;
							'', 'Column Header', This)
						.oColumnFooterBand = newobject('SFReportBand', .ClassLibrary, ;
							'', 'Column Footer', This)
					endif upper(.ClassLibrary) $ set('CLASSLIB')
				case tnValue = 1 and vartype(.oColumnHeaderBand) = 'O'
					.oColumnHeaderBand.Release()
					.oColumnFootBand.Release()
			endcase
			.SetColumnWidth()
		endwith
		
	ENDPROC

	PROCEDURE ndetailbands_access
		This.nDetailBands = iif(isnull(This.aDetailBands[1, 1]), 0, ;
			alen(This.aDetailBands, 1))
		return This.nDetailBands
		
	ENDPROC

	PROCEDURE nfontsize_assign
		lparameter tnValue
		This.nFontSize = tnValue
		This.SetVHFactors()
		
	ENDPROC

	PROCEDURE nfontstyle_assign
		lparameter tnValue
		This.nFontStyle = tnValue
		This.SetVHFactors()
		
	ENDPROC

	PROCEDURE ngroups_access
		This.nGroups = iif(isnull(This.aGroupBands[1, 1]), 0, ;
			alen(This.aGroupBands, 1))
		return This.nGroups
		
	ENDPROC

	PROCEDURE nleftmargin_assign
		lparameter tnValue
		This.nLeftMargin = tnValue
		This.SetColumnWidth()
		
	ENDPROC

	PROCEDURE releasemembers
		* Nuke member objects.
		
		local lnI
		with This
			if vartype(.oTitleBand) = 'O'
				.oTitleBand.Release()
			endif vartype(.oTitleBand) = 'O'
			if vartype(.oPageHeaderBand) = 'O'
				.oPageHeaderBand.Release()
			endif vartype(.oPageHeaderBand) = 'O'
			if vartype(.oDetailBand) = 'O'
				.oDetailBand.Release()
			endif vartype(.oDetailBand) = 'O'
			if vartype(.oSummaryBand) = 'O'
				.oSummaryBand.Release()
			endif vartype(.oSummaryBand) = 'O'
			for lnI = 1 to alen(.aGroupbands)
				if vartype(.aGroupBands[lnI]) = 'O'
					.aGroupBands[lnI].Release()
				endif vartype(.aGroupBands[lnI]) = 'O'
			next lnI
			for lnI = 1 to alen(.aVariables)
				if vartype(.aVariables[lnI]) = 'O'
					.aVariables[lnI].Release()
				endif vartype(.aVariables[lnI]) = 'O'
			next lnI
			if vartype(.oDE) = 'O'
				.oDE.Release()
			endif vartype(.oDE) = 'O'
		endwith
		
	ENDPROC

	PROCEDURE save		&& Creates the report file
		* Create an FRX by spinning through each band in order and processing the
		* objects in it.
		
		local lnSelect, ;
			lnGroups, ;
			lnI, ;
			lnVariables, ;
			llLandscape, ;
			lnTemp
		with This
		
		* Ensure a report file was specified.
		
			if empty(.cReportFile)
				if type('oLocalizer') = 'O'
					error oLocalizer.GetLocalizedString('ERR_NO_REPORT_FILE')
				else
					error 'The name of the report file was not specified.'
				endif type('oLocalizer') = 'O'
				return .F.
			endif empty(.cReportFile)
		
		* Set the current band number and report height and width to 0.
		
			.nBand     = 0
			.nHeight   = 0
			.nRepWidth = 0
		
		* Set the horizontal and vertical factors we'll work with.
		
			.SetVHFactors()
		
		* Create the report and insert the header record.
		
			lnSelect = select()
			.CreateReportFile()
			.InsertHeader()
		
		* Insert the title and page header bands.
		
			if .lTitleBand
				.InsertBand(.oTitleBand)
			endif .lTitleBand
			.InsertBand(.oPageHeaderBand)
		
		* Insert the column header band if necessary.
		
			if .nColumns > 1
				.InsertBand(.oColumnHeaderBand)
			endif .nColumns > 1
		
		* Insert each group header band.
		
			for lnI = 1 to .nGroups
				.InsertBand(.aGroupBands[lnI, 1])
			next lnI
		
		* Insert the detail header band if there is one.
		
			if vartype(.oDetailHeaderBand) = 'O'
				.InsertBand(.oDetailHeaderBand)
			endif vartype(.oDetailHeaderBand) = 'O'
		
		* Insert the detail band.
		
			.InsertBand(.oDetailBand)
		
		* Insert the detail footer band if there is one.
		
			if vartype(.oDetailFooterBand) = 'O'
				.InsertBand(.oDetailFooterBand)
			endif vartype(.oDetailFooterBand) = 'O'
		
		* Insert each additional detail band, with optional header and footer.
		
			for lnI = 1 to .nDetailBands
				if not isnull(.aDetailBands[lnI, 2])
					.InsertBand(.aDetailBands[lnI, 2])
				endif not isnull(.aDetailBands[lnI, 2])
				.InsertBand(.aDetailBands[lnI, 1])
				if not isnull(.aDetailBands[lnI, 3])
					.InsertBand(.aDetailBands[lnI, 3])
				endif not isnull(.aDetailBands[lnI, 3])
			next lnI
		
		* Insert each group footer band (this has to be in reverse order).
		
			for lnI = .nGroups to 1 step -1
				.InsertBand(.aGroupBands[lnI, 2])
			next lnI
		
		* Insert the column footer band if necessary.
		
			if .nColumns > 1
				.InsertBand(.oColumnFooterBand)
			endif .nColumns > 1
		
		* Insert the page footer and summary bands.
		
			.InsertBand(.oPageFooterBand)
			if .lSummaryBand
				.InsertBand(.oSummaryBand)
			endif .lSummaryBand
		
		* Insert the title and page header band objects.
		
			.nFirstObject = recno() + 1
			if .lTitleBand
				.InsertBandObjects(.oTitleBand)
			endif .lTitleBand
			.InsertBandObjects(.oPageHeaderBand)
		
		* Insert the column header band objects if necessary.
		
			if .nColumns > 1
				.InsertBandObjects(.oColumnHeaderBand)
			endif .nColumns > 1
		
		* Insert each group header band's objects.
		
			for lnI = 1 to .nGroups
				.InsertBandObjects(.aGroupBands[lnI, 1])
			next lnI
		
		* Insert the detail header band objects if there is one.
		
			if vartype(.oDetailHeaderBand) = 'O'
				.InsertBandObjects(.oDetailHeaderBand)
			endif vartype(.oDetailHeaderBand) = 'O'
		
		* Insert the detail band objects.
		
			.InsertBandObjects(.oDetailBand)
		
		* Insert the detail footer band objects if there is one.
		
			if vartype(.oDetailFooterBand) = 'O'
				.InsertBandObjects(.oDetailFooterBand)
			endif vartype(.oDetailFooterBand) = 'O'
		
		* Insert each additional detail band objects, with optional header and footer.
		
			for lnI = 1 to .nDetailBands
				if not isnull(.aDetailBands[lnI, 2])
					.InsertBandObjects(.aDetailBands[lnI, 2])
				endif not isnull(.aDetailBands[lnI, 2])
				.InsertBandObjects(.aDetailBands[lnI, 1])
				if not isnull(.aDetailBands[lnI, 3])
					.InsertBandObjects(.aDetailBands[lnI, 3])
				endif not isnull(.aDetailBands[lnI, 3])
			next lnI
		
		* Insert each group footer band's objects (this has to be in reverse order).
		
			for lnI = .nGroups to 1 step -1
				.InsertBandObjects(.aGroupBands[lnI, 2])
			next lnI
		
		* Insert the column footer band objects if necessary.
		
			if .nColumns > 1
				.InsertBandObjects(.oColumnFooterBand)
			endif .nColumns > 1
		
		* Insert the page footer and summary band objects.
		
			.InsertBandObjects(.oPageFooterBand)
			if .lSummaryBand
				.InsertBandObjects(.oSummaryBand)
			endif .lSummaryBand
		
		* Insert the grouped objects records.
		
			lnGroups = iif(empty(.aObjectGroups[1]), 0, alen(.aObjectGroups, 1))
			for lnI = 1 to lnGroups
				.InsertObjectGroup(.aObjectGroups[lnI, 1], .aObjectGroups[lnI, 2])
			next lnI
		
		* Insert the report variables.
		
			lnVariables = iif(isnull(.aVariables[1]), 0, alen(.aVariables))
			for lnI = 1 to lnVariables
				.InsertVariable(.aVariables[lnI])
			next lnI
		
		* Insert the trailer and DataEnvironment records.
		
			.InsertTrailer()
			.InsertDE()
		
		* If the report is wider than the page width can handle or we're supposed to
		* print it in landscape, switch to landscape.
			
			go top
			llLandscape = .nOrientation = cnORIENTATION_LANDSCAPE
			if .nPaperWidth = 0
				.GetPaperWidth(llLandscape)
			endif .nPaperWidth = 0
			if llLandscape or (.nRepWidth > .nMinPaperWidth and ;
				.nOrientation = cnORIENTATION_AUTO)
				replace EXPR with 'ORIENTATION=1'
				if not llLandscape and not .lUsingLandscape
					lnTemp        = .nPaperWidth
					.nPaperWidth  = .nPaperLength
					.nPaperLength = lnTemp
				endif not llLandscape ...
			endif llLandscape ...
			replace EXPR with EXPR + iif(empty(EXPR), '', ccCRLF) + ;
				'PAPERSIZE=' + transform(.nPaperSize) + ;
				iif(.nDefaultSource >= 0, ccCRLF + 'DEFAULTSOURCE=' + transform(.nDefaultSource), '') + ;
				iif(empty(.cDevice), '', ccCRLF + 'DEVICE=' + .cDevice)
			if not empty(.cTag)
				replace TAG with .cTag, TAG2 with .cTag2
			endif not empty(.cTag)
		
		* Now make sure no objects are wider than the paper width.
		
			if .lAdjustObjectWidths
				replace WIDTH with .nPaperWidth - HPOS for HPOS + WIDTH > .nPaperWidth
			endif .lAdjustObjectWidths
		
		* Close the report file.
		
			use
			select (lnSelect)
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE setcolumnwidth		&& Sets the width of the report based on column width
		* If we have more than one column, set nWidth and lSetHeaderWidth.
		
		local llLandscape, ;
			lnColumnSpacing, ;
			lnLeftMargin
		with This
			if .nColumns > 1
				.lSetHeaderWidth = .T.
				llLandscape      = .nOrientation = cnORIENTATION_LANDSCAPE
				lnColumnSpacing  = iif(.nColumnSpacing < 0, -.nColumnSpacing, ;
					.nColumnSpacing * .nHFactor)
				lnLeftMargin     = iif(.nLeftMargin < 0, -.nLeftMargin, ;
					.nLeftMargin * .nHFactor)
				.nWidth          = - (.GetPaperWidth(llLandscape) - ;
					lnColumnSpacing * (.nColumns - 1) - lnLeftMargin)/.nColumns
			else
				.lSetHeaderWidth = .F.
			endif tnValue > 1
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE setvhfactors		&& Sets the vertical and horizontal factors we'll work with
		* Calculate the factors to convert character units into report units.
		
		with This
			do case
		
		* For proportional fonts, we'll use the size of the "average" character in a
		* font as the horizontal factor.
		
				case .cUnits = ccUNITS_CHARACTERS
					.nVFactor = .GetVFactor(This)
					.nHFactor = .GetHFactor(This)
		
		* For an inches scale, use the report units factor.
		
				case .cUnits = ccUNITS_INCHES
					.nVFactor = cnREPORT_UNITS
					.nHFactor = cnREPORT_UNITS
		
		* For an centimeter scale, use the report units factor divided by the number of
		* centimeters per inch.
		
				case .cUnits = ccUNITS_CENTIMETERS
					.nVFactor = cnREPORT_UNITS/2.54
					.nHFactor = cnREPORT_UNITS/2.54
			endcase
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportgroup AS sfreportband OF "sfrepobj.vcx" 		&& Report group class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*p: cexpression		&& The group expression
		*p: lprintoneachpage		&& .T. to print the group header on each page
		*p: lresetpage		&& .T. to reset the page number for each page to 1
		*p: lstartinnewcolumn		&& .T. if each group should start in a new column
	*</DefinedPropArrayMethod>

	cexpression = 		&& The group expression
	lprintoneachpage = .F.		&& .T. to print the group header on each page
	lresetpage = .F.		&& .T. to reset the page number for each page to 1
	lstartinnewcolumn = .F.		&& .T. if each group should start in a new column
	Name = "sfreportgroup"
	nnewpagewhenlessthan = 0
	_memberdata = <VFPData>
		<memberdata name="cexpression" type="property" display="cExpression"/>
		<memberdata name="lprintoneachpage" type="property" display="lPrintOnEachPage"/>
		<memberdata name="lprintoneachpage_assign" type="method" display="lPrintOnEachPage_Assign"/>
		<memberdata name="lresetpage" type="property" display="lResetPage"/>
		<memberdata name="lresetpage_assign" type="method" display="lResetPage_Assign"/>
		<memberdata name="lstartinnewcolumn" type="property" display="lStartInNewColumn"/>
		<memberdata name="lstartinnewcolumn_assign" type="method" display="lStartInNewColumn_Assign"/>
		<memberdata name="nnewpagewhenlessthan" type="property" display="nNewPageWhenLessThan"/>
		<memberdata name="nnewpagewhenlessthan_assign" type="method" display="nNewPageWhenLessThan_Assign"/>
		</VFPData>
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		local lcBandType, ;
			lnType
		dodefault(toRecord, toReport)
		with This
			lcBandType = upper(.cBandType)
			if lcBandType = ccBAND_GROUP_HEADER
				lnType = cnREPOBJ_CODE_GPHEADER
			else
				lnType = cnREPOBJ_CODE_GPFOOTER
			endif lcBandType = ccBAND_GROUP_HEADER
			toRecord.ObjCode   = lnType
			toRecord.Expr      = .cExpression
			toRecord.PageBreak = .lStartOnNewPage or .lResetPage
			toRecord.ColBreak  = .lStartInNewColumn
			toRecord.NoRepeat  = .lPrintOnEachPage
			toRecord.ResetPage = .lResetPage
		endwith
		return
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		with This
			.cBandType         = iif(OBJCODE = cnREPOBJ_CODE_GPHEADER, ;
				ccBAND_GROUP_HEADER, ccBAND_GROUP_FOOTER)
			.cExpression       = EXPR
			.lPrintOnEachPage  = NOREPEAT
			.lResetPage        = RESETPAGE
			.lStartInNewColumn = COLBREAK
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportimage AS sfreportobject OF "sfrepobj.vcx" 		&& Report image class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*p: cimagesource		&& The name of the image file or General field that's the source for the image
		*p: nimagesource		&& 0 if the image comes from a file, 1 if it comes from a General field, or 2 if it's an expression
		*p: nstretch		&& How to scale the image: 0 = clip, 1 = isometric, 2 = stretch
	*</DefinedPropArrayMethod>

	cimagesource = 		&& The name of the image file or General field that's the source for the image
	lautocenter = .F.
	Name = "sfreportimage"
	nimagesource = 0		&& 0 if the image comes from a file, 1 if it comes from a General field, or 2 if it's an expression
	nobjecttype = 17
	nstretch = 0		&& How to scale the image: 0 = clip, 1 = isometric, 2 = stretch
	_memberdata = <VFPData>
		<memberdata name="cimagesource" type="property" display="cImageSource"/>
		<memberdata name="cimagesource_assign" type="method" display="cImageSource_Assign"/>
		<memberdata name="limagefile" type="property" display="lImageFile"/>
		<memberdata name="limagefile_assign" type="method" display="lImageFile_Assign"/>
		<memberdata name="nstretch" type="property" display="nStretch"/>
		<memberdata name="nstretch_assign" type="method" display="nStretch_Assign"/>
		<memberdata name="nimagesource" type="property" display="nImageSource"/>
		</VFPData>
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		dodefault(toRecord, toReport)
		with This
			if .nImageSource = FRX_PICTURE_SOURCE_FILENAME
				if left(.cImageSource, 1) $ ["']
					toRecord.Picture = .cImageSource
				else
					toRecord.Picture = '"' + .cImageSource + '"'
				endif left(.cImageSource, 1) $ ["']
			else
				toRecord.Name   = .cImageSource
				toRecord.Double = .cAlignment = ccALIGN_CENTER
			endif .nImageSource = FRX_PICTURE_SOURCE_FILENAME
			toRecord.Offset  = .nImageSource
			toRecord.General = .nStretch
		endwith
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		with This
			.cAlignment   = iif(DOUBLE, ccALIGN_CENTER, ccALIGN_LEFT)
			.cImageSource = iif(OFFSET = FRX_PICTURE_SOURCE_FILENAME, ;
				strtran(PICTURE, '"'), NAME)
			.nImageSource = OFFSET
			.nStretch     = GENERAL
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportline AS sfreportshape OF "sfrepobj.vcx" 		&& Report line class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*p: lvertical		&& .T. if this is a vertical line; otherwise, it's horizontal
	*</DefinedPropArrayMethod>

	lvertical = .F.		&& .T. if this is a vertical line; otherwise, it's horizontal
	Name = "sfreportline"
	_memberdata = <VFPData>
		<memberdata name="calignment" type="property" display="cAlignment"/>
		<memberdata name="calignment_assign" type="method" display="cAlignment_Assign"/>
		<memberdata name="cname" type="property" display="cName"/>
		<memberdata name="cprintwhen" type="property" display="cPrintWhen"/>
		<memberdata name="cprintwhen_assign" type="method" display="cPrintWhen_Assign"/>
		<memberdata name="lvertical" type="property" display="lVertical"/>
		<memberdata name="lvertical_assign" type="method" display="lVertical_Assign"/>
		</VFPData>
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		dodefault(toRecord, toReport)
		with This
		
		* Fix either the width or the height of the line, depending on whether this is
		* a vertical or horizontal line.
		
			if .lVertical
				toRecord.Width  = - cnFACTOR * max(.nPenSize, 1)
				toRecord.Offset = 0
			else
				toRecord.Height = - cnFACTOR * max(.nPenSize, 1)
				toRecord.Offset = 1
			endif .lVertical
		endwith
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		This.lVertical = OFFSET = 0
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportobject AS sfreportrecord OF "sfrepobj.vcx" 		&& Base class for objects in a report
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*m: lprintrepeats_assign
		*p: calignment		&& The alignment for the object: "left", "center", or "right"
		*p: cname		&& A name for the object (used by SFReportBand.Item to locate an item by name)
		*p: cprintwhen		&& The Print When expression
		*p: ctooltip		&& The Tooltip for the object
		*p: lautocenter		&& .T. to automatically center this object vertically in a row when using character units for the report
		*p: lprintinfirstwholeband		&& .T. to print in the first whole band of a new page
		*p: lprintonnewpage		&& .T. to print when the detail band overflows to a new page
		*p: lprintrepeats		&& .T. to print repeated values
		*p: lremovelineifblank		&& .T. to remove a line if there are no objects on it
		*p: lstretch		&& .T. if the object can stretch
		*p: ltransparent		&& .T. if the object is transparent, .F. for opaque
		*p: nbackcolor		&& The object's background color (-1 = default)
		*p: nfloat		&& 0 if the object should float in its band, 1 if it should be positioned relative to the top of the band, or 2 if it should be relative to the bottom of the band
		*p: nforecolor		&& The object's foreground color (-1 = default)
		*p: ngroup		&& Non-zero if this object is grouped with other objects
		*p: nheight		&& The height of the object
		*p: nhposition		&& The horizontal position for the object
		*p: nprintongroupchange		&& The group number if this object should print on a group change
		*p: nvabsoluteposition		&& The vertical position of the object as read from an FRX
		*p: nvposition		&& The vertical position for the object relative to the top of the band
		*p: nwidth		&& The width of the object
	*</DefinedPropArrayMethod>

	calignment = Left		&& The alignment for the object: "left", "center", or "right"
	cname = 		&& A name for the object (used by SFReportBand.Item to locate an item by name)
	cprintwhen = 		&& The Print When expression
	ctooltip = 		&& The Tooltip for the object
	lautocenter = .T.		&& .T. to automatically center this object vertically in a row when using character units for the report
	lprintinfirstwholeband = .T.		&& .T. to print in the first whole band of a new page
	lprintonnewpage = .F.		&& .T. to print when the detail band overflows to a new page
	lprintrepeats = .T.		&& .T. to print repeated values
	lremovelineifblank = .F.		&& .T. to remove a line if there are no objects on it
	lstretch = .F.		&& .T. if the object can stretch
	ltransparent = .T.		&& .T. if the object is transparent, .F. for opaque
	Name = "sfreportobject"
	nbackcolor = -1		&& The object's background color (-1 = default)
	nfloat = 1		&& 0 if the object should float in its band, 1 if it should be positioned relative to the top of the band, or 2 if it should be relative to the bottom of the band
	nforecolor = -1		&& The object's foreground color (-1 = default)
	ngroup = 0		&& Non-zero if this object is grouped with other objects
	nheight = 0		&& The height of the object
	nhposition = 0		&& The horizontal position for the object
	nprintongroupchange = 0		&& The group number if this object should print on a group change
	nvabsoluteposition = 0		&& The vertical position of the object as read from an FRX
	nvposition = 0		&& The vertical position for the object relative to the top of the band
	nwidth = 0		&& The width of the object
	_memberdata = <VFPData>
		<memberdata name="calignment" type="property" display="cAlignment"/>
		<memberdata name="calignment_assign" type="method" display="cAlignment_Assign"/>
		<memberdata name="cname" type="property" display="cName"/>
		<memberdata name="cprintwhen" type="property" display="cPrintWhen"/>
		<memberdata name="cprintwhen_assign" type="method" display="cPrintWhen_Assign"/>
		<memberdata name="ctooltip" type="property" display="cTooltip"/>
		<memberdata name="lautocenter" type="property" display="lAutoCenter"/>
		<memberdata name="lautocenter_assign" type="method" display="lAutoCenter_Assign"/>
		<memberdata name="lprintinfirstwholeband" type="property" display="lPrintInFirstWholeBand"/>
		<memberdata name="lprintinfirstwholeband_assign" type="method" display="lPrintInFirstWholeBand_Assign"/>
		<memberdata name="lprintonnewpage" type="property" display="lPrintOnNewPage"/>
		<memberdata name="lprintonnewpage_assign" type="method" display="lPrintOnNewPage_Assign"/>
		<memberdata name="lprintrepeats" type="property" display="lPrintRepeats"/>
		<memberdata name="lprintrepeats_assign" type="method" display="lPrintRepeats_Assign"/>
		<memberdata name="lremovelineifblank" type="property" display="lRemoveLineIfBlank"/>
		<memberdata name="lremovelineifblank_assign" type="method" display="lRemoveLineIfBlank_Assign"/>
		<memberdata name="lstretch" type="property" display="lStretch"/>
		<memberdata name="lstretch_assign" type="method" display="lStretch_Assign"/>
		<memberdata name="ltransparent" type="property" display="lTransparent"/>
		<memberdata name="ltransparent_assign" type="method" display="lTransparent_Assign"/>
		<memberdata name="nbackcolor" type="property" display="nBackColor"/>
		<memberdata name="nbackcolor_assign" type="method" display="nBackColor_Assign"/>
		<memberdata name="nfloat" type="property" display="nFloat"/>
		<memberdata name="nfloat_assign" type="method" display="nFloat_Assign"/>
		<memberdata name="nforecolor" type="property" display="nForeColor"/>
		<memberdata name="nforecolor_assign" type="method" display="nForeColor_Assign"/>
		<memberdata name="nheight" type="property" display="nHeight"/>
		<memberdata name="nheight_assign" type="method" display="nHeight_Assign"/>
		<memberdata name="nhposition" type="property" display="nHPosition"/>
		<memberdata name="nhposition_assign" type="method" display="nHPosition_Assign"/>
		<memberdata name="nprintongroupchange" type="property" display="nPrintOnGroupChange"/>
		<memberdata name="nprintongroupchange_assign" type="method" display="nPrintOnGroupChange_Assign"/>
		<memberdata name="nvposition" type="property" display="nVPosition"/>
		<memberdata name="nvposition_assign" type="method" display="nVPosition_Assign"/>
		<memberdata name="nwidth" type="property" display="nWidth"/>
		<memberdata name="nwidth_assign" type="method" display="nWidth_Assign"/>
		<memberdata name="ngroup" type="property" display="nGroup"/>
		<memberdata name="nvabsoluteposition" type="property" display="nVAbsolutePosition"/>
		</VFPData>
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		local lcAlign
		dodefault(toRecord, toReport)
		with This
		
		* Handle the object's height, width, top, and left.
		
			toRecord.VPos   = .nVPosition
			toRecord.HPos   = .nHPosition
			toRecord.Width  = .nWidth
			toRecord.Height = .nHeight
		
		* Handle the object's stretch and positioning properties.
		
			toRecord.Stretch = .lStretch
			do case
				case .nFloat = cnPOSITION_FLOAT
					toRecord.Float  = .T.
					toRecord.Top    = .F.
					toRecord.Bottom = .F.
				case .nFloat = cnPOSITION_TOP
					toRecord.Float  = .F.
					toRecord.Top    = .T.
					toRecord.Bottom = .F.
				case .nFloat = cnPOSITION_BOTTOM
					toRecord.Float  = .F.
					toRecord.Top    = .F.
					toRecord.Bottom = .T.
			endcase
		
		* Handle the object's color.
		
			if .nForeColor = -1
				toRecord.PenRed   = -1
				toRecord.PenGreen = -1
				toRecord.PenBlue  = -1
			else
				toRecord.PenRed   = bitand(.nForeColor, 255)
				toRecord.PenGreen = bitrshift(bitand(.nForeColor, 256^2 - 1), 8)
				toRecord.PenBlue  = bitrshift(bitand(.nForeColor, 256^3 - 1), 16)
			endif .nForeColor = -1
			if .nBackColor = -1
				toRecord.FillRed   = -1
				toRecord.FillGreen = -1
				toRecord.FillBlue  = -1
			else
				toRecord.FillRed   = bitand(.nBackColor, 255)
				toRecord.FillGreen = bitrshift(bitand(.nBackColor, 256^2 - 1), 8)
				toRecord.FillBlue  = bitrshift(bitand(.nBackColor, 256^3 - 1), 16)
			endif .nBackColor = -1
		
		* Handle other properties.
		
			toRecord.Mode     = iif(.lTransparent and .nBackColor = -1, ;
				cnMODE_TRANSPARENT, cnMODE_OPAQUE)
				&& Must use opaque or background color doesn't show
			toRecord.NoRepeat = .lRemoveLineIfBlank
			toRecord.Tag2     = .cTooltip
		
		* Handle "Print When" properties.
		
			toRecord.SupAlways  = .lPrintRepeats
			toRecord.SupValChng = not .lPrintRepeats
			toRecord.SuprPCol   = iif(.lPrintInFirstWholeBand, 3, 0)
			toRecord.SupOvFlow  = .lPrintOnNewPage
			toRecord.SupExpr    = .cPrintWhen
			toRecord.SupGroup   = .nPrintOnGroupChange + ;
				iif(.nPrintOnGroupChange > 0, cnGROUP_OFFSET, 0)
		endwith
		
	ENDPROC

	PROCEDURE Init
		lparameters toReport
		dodefault()
		
	ENDPROC

	PROCEDURE lprintrepeats_assign
		lparameter tlValue
		with This
			.lPrintRepeats = tlValue
			if tlValue
				.lPrintInFirstWholeBand = .T.
				.nPrintOnGroupChange    = 0
				.lPrintOnNewPage        = .F.
			endif tlValue
		endwith
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		with This
			.cPrintWhen             = SUPEXPR
			.cTooltip               = TAG2
			.lPrintInFirstWholeBand = SUPRPCOL = 3
			.lPrintOnNewPage        = SUPOVFLOW
			.lPrintRepeats          = SUPALWAYS
			.lRemoveLineIfBlank     = NOREPEAT
			.lStretch               = STRETCH
			.lTransparent           = MODE = cnMODE_TRANSPARENT
			.nBackColor             = iif(FILLRED = -1, -1, ;
				rgb(FILLRED, FILLGREEN, FILLBLUE))
			.nFloat                 = icase(FLOAT, cnPOSITION_FLOAT, ;
				TOP, cnPOSITION_TOP, BOTTOM, cnPOSITION_BOTTOM)
			.nForeColor             = iif(PENRED = -1, -1, ;
				rgb(PENRED, PENGREEN, PENBLUE))
			.nHeight                = -HEIGHT
			.nHPosition             = -HPOS
			.nPrintOnGroupChange    = max(SUPGROUP - cnGROUP_OFFSET, 0)
			.nVAbsolutePosition     = -VPOS
			.nVPosition             = -VPOS
			.nWidth                 = -WIDTH
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportrecord AS sfreportbase OF "sfrepobj.vcx" 		&& Base class for records in an FRX
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*m: createrecord		&& Creates a report record
		*m: readfromfrx		&& Populates the properties of the object from the current record in the FRX
		*p: ccomment		&& The comment for the report record
		*p: cmemberdata		&& The member data for the report record
		*p: cuniqueid		&& The unique ID for the report record (normally left blank and auto-assigned)
		*p: cuser		&& User-defined property
		*p: nobjecttype		&& The object type code
		*p: recno		&& The record number of the object in the report
	*</DefinedPropArrayMethod>

	PROTECTED nobjecttype
	ccomment = 		&& The comment for the report record
	cmemberdata = 		&& The member data for the report record
	cuniqueid = 		&& The unique ID for the report record (normally left blank and auto-assigned)
	cuser = 		&& User-defined property
	Name = "sfreportrecord"
	nobjecttype = 0		&& The object type code
	recno = 0		&& The record number of the object in the report
	_memberdata = <VFPData>
		<memberdata name="ccomment" type="property" display="cComment"/>
		<memberdata name="createrecord" type="method" display="CreateRecord"/>
		<memberdata name="cuser" type="property" display="cUser"/>
		<memberdata name="nobjecttype" type="property" display="nObjectType"/>
		<memberdata name="cmemberdata" type="property" display="cMemberData"/>
		<memberdata name="cuniqueid" type="property" display="cUniqueID"/>
		<memberdata name="recno" type="property" display="Recno"/>
		<memberdata name="readfromfrx" type="method" display="ReadFromFRX"/>
		</VFPData>
	
	PROCEDURE createrecord		&& Creates a report record
		lparameters toRecord, ;
			toReport
		assert vartype(toRecord) = 'O' and type('toRecord.ObjType') = 'N' ;
			message 'SFReportRecord: invalid toRecord parameter'
		assert vartype(toReport) = 'O' ;
			message 'SFReportRecord: invalid toReport parameter'
		toRecord.ObjType = This.nObjectType
		toRecord.Comment = This.cComment
		toRecord.User    = This.cUser
		toRecord.Style   = This.cMemberData
		if not empty(This.cUniqueID)
			toRecord.UniqueID = This.cUniqueID
		endif not empty(This.cUniqueID)
		return
		
	ENDPROC

	PROCEDURE readfromfrx		&& Populates the properties of the object from the current record in the FRX
		with This
			.Recno       = recno()
			.cUniqueID   = UNIQUEID
			.cComment    = COMMENT
			.cMemberData = STYLE
			.cUser       = USER
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportshape AS sfreportobject OF "sfrepobj.vcx" 		&& Report shape class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*p: npenpattern		&& The pen pattern for the object: 0 = none, 1 = dotted, 2 = dashed, 3 = dash-dot, 4 = dash-dot-dot, 8 = normal
		*p: npensize		&& The pen size for the line: 0, 1, 2, 4, or 6
	*</DefinedPropArrayMethod>

	lautocenter = .F.
	Name = "sfreportshape"
	nobjecttype = 6
	npenpattern = 8		&& The pen pattern for the object: 0 = none, 1 = dotted, 2 = dashed, 3 = dash-dot, 4 = dash-dot-dot, 8 = normal
	npensize = 1		&& The pen size for the line: 0, 1, 2, 4, or 6
	nprintongroupchange = 1
	_memberdata = <VFPData>
		<memberdata name="npenpattern" type="property" display="nPenPattern"/>
		<memberdata name="npenpattern_assign" type="method" display="nPenPattern_Assign"/>
		<memberdata name="npensize" type="property" display="nPenSize"/>
		<memberdata name="npensize_assign" type="method" display="nPenSize_Assign"/>
		</VFPData>
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		dodefault(toRecord, toReport)
		with This
			toRecord.PenSize = .nPenSize
			toRecord.PenPat  = .nPenPattern
		endwith
		return
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		with This
			.nPenPattern = PENPAT
			.nPenSize    = PENSIZE
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreporttext AS sfreportfield OF "sfrepobj.vcx" 		&& Report text object class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	cdatatype = 
	Name = "sfreporttext"
	nobjecttype = 5
	
	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		local lcAlignment, ;
			lnAdjust
		dodefault(toRecord, toReport)
		with This
		
		* Ensure we have valid properties.
		
			assert vartype(.cExpression) = 'C' and not empty(.cExpression) ;
				message 'SFReportText: invalid cExpression property'
			assert vartype(.cAlignment) = 'C' ;
				message 'SFReportText: invalid cAlignment property'
			assert vartype(.nWidth) = 'N' ;
				message 'SFReportText: invalid nWidth property'
		
		* Add quotes around the expression and determine the picture based on the
		* alignment.
		
			toRecord.Expr = '"' + .cExpression + '"'
			lcAlignment = upper(.cAlignment)
			do case
				case lcAlignment = upper(ccALIGN_CENTER)
					toRecord.Picture = '"@I"'
				case lcAlignment = upper(ccALIGN_RIGHT)
					toRecord.Picture = '"@J"'
			endcase
		
		* Set ResetTotal to 0 (SFReportField will have set it to 1).
		
			toRecord.ResetTotal = 0
		
		* If a width wasn't defined, use the width of the expression.
		
			if .nWidth = 0
				lnAdjust = txtwidth(ccAVG_CHAR, .cFontName, .nFontSize, ;
					.cFontStyle)/cnTXTWIDTH_FUDGE
				toRecord.Width = toReport.GetHValue(txtwidth(.cExpression, ;
					.cFontName, .nFontSize, .cFontStyle)/lnAdjust, This)
			endif .nWidth = 0
		endwith
		return
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		This.cExpression = substr(EXPR, 2, len(EXPR) - 2)
		This.cAlignment  = icase(PICTURE = '"@I"', ccALIGN_CENTER, ;
			PICTURE = '"@J"', ccALIGN_RIGHT, ccALIGN_LEFT)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfreportvariable AS sfreportrecord OF "sfrepobj.vcx" 		&& Report variable class
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "sfrepobj.h"
	*<DefinedPropArrayMethod>
		*m: cinitialvalue_assign
		*p: cinitialvalue		&& The initial value
		*p: cname		&& The variable name
		*p: ctotaltype		&& The total type: "N" for none, "C" for count, "S" for sum, "A" for average, "L" for lowest, "H" for highest, "D" for standard deviation, and "V" for variance
		*p: cvalue		&& The value to store
		*p: lreleaseatend		&& .T. to release the variable at the end of the report
		*p: lresetonpage		&& .T. to reset the variable at the end of each page; .F. to reset at the end of the report
		*p: nresetongroup		&& The group number to reset the variable on
	*</DefinedPropArrayMethod>

	cinitialvalue = 		&& The initial value
	cname = 		&& The variable name
	ctotaltype = N		&& The total type: "N" for none, "C" for count, "S" for sum, "A" for average, "L" for lowest, "H" for highest, "D" for standard deviation, and "V" for variance
	cvalue = 		&& The value to store
	lreleaseatend = .T.		&& .T. to release the variable at the end of the report
	lresetonpage = .F.		&& .T. to reset the variable at the end of each page; .F. to reset at the end of the report
	Name = "sfreportvariable"
	nobjecttype = 18
	nresetongroup = 0		&& The group number to reset the variable on
	_memberdata = <VFPData>
		<memberdata name="cinitialvalue" type="property" display="cInitialValue"/>
		<memberdata name="cinitialvalue_assign" type="method" display="cInitialValue_Assign"/>
		<memberdata name="cname" type="property" display="cName"/>
		<memberdata name="cname_assign" type="method" display="cName_Assign"/>
		<memberdata name="ctotaltype" type="property" display="cTotalType"/>
		<memberdata name="ctotaltype_assign" type="method" display="cTotalType_Assign"/>
		<memberdata name="cvalue" type="property" display="cValue"/>
		<memberdata name="lreleaseatend" type="property" display="lReleaseAtEnd"/>
		<memberdata name="lreleaseatend_assign" type="method" display="lReleaseAtEnd_Assign"/>
		<memberdata name="lresetonpage" type="property" display="lResetOnPage"/>
		<memberdata name="lresetonpage_assign" type="method" display="lResetOnPage_Assign"/>
		<memberdata name="nresetongroup" type="property" display="nResetOnGroup"/>
		<memberdata name="nresetongroup_assign" type="method" display="nResetOnGroup_Assign"/>
		</VFPData>
	
	PROCEDURE cinitialvalue_assign
		lparameters tuValue
		local lcSetPoint
		This.cInitialValue = transform(tuValue)
		if vartype(tuValue) $ 'NFIBY'
			lcSetPoint = set('POINT')
			set point to '.'
			This.cInitialValue = alltrim(transform(tuValue, ;
				'999999999999999999.999999'))
			set point to &lcSetPoint
		endif vartype(tuValue) $ 'NFIBY'
		
	ENDPROC

	PROCEDURE createrecord
		lparameters toRecord, ;
			toReport
		local lcTotalType
		dodefault(toRecord, toReport)
		with This
			toRecord.Name   = .cName
			toRecord.Expr   = iif(vartype(.cValue) = 'C', .cValue, transform(.cValue))
			toRecord.Tag    = iif(vartype(.cInitialValue) = 'C', .cInitialValue, ;
				transform(.cInitialValue))
			toRecord.Unique = .lReleaseAtEnd
			lcTotalType     = upper(left(.cTotalType, 1))
			do case
				case lcTotalType = ccTOTAL_NONE
					toRecord.TotalType = cnTOTAL_NONE
				case lcTotalType = ccTOTAL_COUNT
					toRecord.TotalType = cnTOTAL_COUNT
				case lcTotalType = ccTOTAL_SUM
					toRecord.TotalType = cnTOTAL_SUM
				case lcTotalType = ccTOTAL_AVERAGE
					toRecord.TotalType = cnTOTAL_AVERAGE
				case lcTotalType = ccTOTAL_LOWEST
					toRecord.TotalType = cnTOTAL_LOWEST
				case lcTotalType = ccTOTAL_HIGHEST
					toRecord.TotalType = cnTOTAL_HIGHEST
				case lcTotalType = ccTOTAL_STDDEV
					toRecord.TotalType = cnTOTAL_STDDEV
				case lcTotalType = ccTOTAL_VARIANCE
					toRecord.TotalType = cnTOTAL_VARIANCE
			endcase
			toRecord.ResetTotal = iif(.nResetOnGroup = 0, iif(.lResetOnPage, 2, 1), ;
				.nResetOnGroup + cnGROUP_OFFSET)
		endwith
		return
		
	ENDPROC

	PROCEDURE readfromfrx
		dodefault()
		with This
			.cInitialValue = TAG
			.cName         = NAME
			.cValue        = EXPR
			.lReleaseAtEnd = UNIQUE
			.lResetOnPage  = RESETTOTAL = 2
			.nResetOnGroup = max(RESETTOTAL - cnGROUP_OFFSET, 0)
			do case
				case TOTALTYPE = cnTOTAL_NONE
					.cTotalType = ccTOTAL_NONE
				case TOTALTYPE = cnTOTAL_COUNT
					.cTotalType = ccTOTAL_COUNT
				case TOTALTYPE = cnTOTAL_SUM
					.cTotalType = ccTOTAL_SUM
				case TOTALTYPE = cnTOTAL_AVERAGE
					.cTotalType = ccTOTAL_AVERAGE
				case TOTALTYPE = cnTOTAL_LOWEST
					.cTotalType = ccTOTAL_LOWEST
				case TOTALTYPE = cnTOTAL_HIGHEST
					.cTotalType = ccTOTAL_HIGHEST
				case TOTALTYPE = cnTOTAL_STDDEV
					.cTotalType = ccTOTAL_STDDEV
				case TOTALTYPE = cnTOTAL_VARIANCE
					.cTotalType = ccTOTAL_VARIANCE
			endcase
		endwith
		
	ENDPROC

ENDDEFINE
